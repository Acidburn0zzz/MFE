set include BOOL off .
set include BOOL-OPS off .
set include TRUTH-VALUE on .

  fmod MBOOL is
    vars B B' : Bool .
    op not_ : Bool -> Bool .
    eq not true = false .
    eq not false = true .
    
    op _==_ : Bool Bool -> Bool [comm prec 15] .
    eq true == false = false .
    eq B == B = true .
    
    op if_then_else_fi : Bool Bool Bool -> Bool [strat (1 0 2 3 0)] .
    eq if true then B else B' fi = B .
    eq if false then B else B' fi = B' .
  endfm
  
  fmod MNAT is
    pr MBOOL .

    sorts Nat NzNat Zero .
    subsorts Zero NzNat < Nat .

    op 0 : -> Zero [ctor] .
    op s_ : Nat -> NzNat [ctor] .

    vars N N' : Nat .

    op _<_ : Nat Nat -> Bool .
    eq 0 < s N = true .
    eq s N < 0 = false .
    eq N < N = false .
    eq s N < s N' = N < N' .

    op _==_ : Nat Nat -> Bool [comm prec 15] .
    eq 0 == s N = false .
    eq N == N = true .
    eq s N == s N' = N == N' .
    
    op if_then_else_fi : Bool Nat Nat -> Nat [strat (1 0 2 3 0)] .
    eq if true then N else N' fi = N .
    eq if false then N else N' fi = N' .
  endfm

  fth MTRIV is 
    pr TRUTH-VALUE .
    sort Elt .
    op _==_ : Elt Elt -> Bool [comm prec 15] .
  endfth 
  
fmod MLIST{X :: MTRIV} is
  protecting MNAT .
  sorts NeList{X} List{X} .
  subsort X$Elt < NeList{X} < List{X} .

  op nil : -> List{X} [ctor] .
  op __ : List{X} List{X} -> List{X} [ctor assoc id: nil prec 25] .
  op __ : NeList{X} List{X} -> NeList{X} [ctor ditto] .
  op __ : List{X} NeList{X} -> NeList{X} [ctor ditto] .

  vars E E' : X$Elt .
  vars A L : List{X} .
  vars C N : Nat .

  op append : List{X} List{X} -> List{X} .
  op append : NeList{X} List{X} -> NeList{X} .
  op append : List{X} NeList{X} -> NeList{X} .
  eq [MLIST-01] : append(A, L) = A L .

  op head : NeList{X} -> X$Elt .
  eq [MLIST-02] : head(E L) = E .

  op tail : NeList{X} -> List{X} .
  eq [MLIST-03] : tail(E L) = L .

  op last : NeList{X} -> X$Elt .
  eq [MLIST-04] : last(L E) = E .

  op front : NeList{X} -> List{X} .
  eq [MLIST-05] : front(L E) = L .

  op occurs : X$Elt List{X} -> Bool .
  eq [MLIST-06] : occurs(E, nil) = false .
  eq [MLIST-07] : occurs(E, E L) = true .
 ceq [MLIST-08] : occurs(E, E' L) = occurs(E, L) if not E == E' .

  op reverse : List{X} -> List{X} .
  op reverse : NeList{X} -> NeList{X} .
  eq [MLIST-09] : reverse(L) = $reverse(L, nil) .

  op $reverse : List{X} List{X} -> List{X} .
  op $reverse : NeList{X} List{X} -> NeList{X} .
  op $reverse : List{X} NeList{X} -> NeList{X} .
  eq [MLIST-10] : $reverse(nil, A) = A .
  eq [MLIST-11] : $reverse(E L, A) = $reverse(L, E A).

  op size : List{X} -> Nat .
  op size : NeList{X} -> NzNat .
  eq [MLIST-12] : size(L) = $size(L, 0) .

  op $size : List{X} Nat -> Nat .
  eq [MLIST-13] : $size(nil, C) = C .
  eq [MLIST-14] : $size(E L, C) = $size(L, s C) .
  
  op take_from_ : Nat List{X} -> List{X} .
  op throw_from_ : Nat List{X} -> List{X} .
    
  eq take 0 from L = nil .
  eq take N from nil = nil .
  eq take s N from (E L) = E take N from L .
    
  eq throw 0 from L = L .
  eq throw N from nil = nil .
  eq throw s N from (E L) = throw N from L .
endfm

view mNat from MTRIV to MNAT is
  sort Elt to Nat .
endv

fmod MNAT-MLIST is
  pr MLIST{mNat} .
endfm

select MFE .
loop init .

 (set include BOOL off .)
 (set include BOOL-OPS off .)
 (set include TRUTH-VALUE on .)
 (select tool CRC .)
set trace off .
set trace select on .
set print conceal off .
trace select ---- crcContextJoinableAndUnfeasibleCPs 
             ---- maximalCPSet 
             ---- delete 
             ---- simplify 
             ---- crcCritPairs
             ---- confluenceCheck
             ---- prepNarrowingSols
             metaNarrowSearch
             .
 (ccr MNAT-MLIST .)
