MTT -> AProVE: 
( VAR X X@@@ Y Z l' n )  ( THEORY   ( AC @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@ )  )   ( RULES   @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@ ( 0 ,  X ) -> X   @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@ ( X@@@ ,  @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( n ) ) -> @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@ ( 1 ,  X@@@ )   @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@ ( X@@@ ,  @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( nil ) ) -> X@@@   @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@ ( X@@@ ,  @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( @underscore@@underscore@-@osb@List@csb@-@osb@List@csb@ ( n ,  l' ) ) ) -> @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@-@osb@List@csb@ ( 1 ,  X@@@ ,  @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( l' ) )   @underscore@@underscore@-@osb@List@csb@-@osb@List@csb@ ( @underscore@@underscore@-@osb@List@csb@-@osb@List@csb@ ( X ,  Y ) ,  Z ) -> @underscore@@underscore@-@osb@List@csb@-@osb@List@csb@ ( X ,  @underscore@@underscore@-@osb@List@csb@-@osb@List@csb@ ( Y ,  Z ) )   @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( n ) -> 1   @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( nil ) -> 0   @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( @underscore@@underscore@-@osb@List@csb@-@osb@List@csb@ ( n ,  l' ) ) -> @underscore@+@underscore@-@osb@List@csb@-@osb@List@csb@ ( 1 ,  @vertical-bar@@underscore@@vertical-bar@-@osb@List@csb@ ( l' ) )  )  

AProVE -> MTT: 
YES
Term Rewriting System R:

   [X, X@@@, n, l', Y, Z]
   AC [_+_-`[List`]-`[List`]]
   _+_-`[List`]-`[List`](0, X) -> X
   _+_-`[List`]-`[List`](X@@@, |_|-`[List`](n)) -> _+_-`[List`]-`[List`](1, X@@@)
   _+_-`[List`]-`[List`](X@@@, |_|-`[List`](nil)) -> X@@@
   _+_-`[List`]-`[List`](X@@@, |_|-`[List`](__-`[List`]-`[List`](n, l'))) -> _+_-`[List`]-`[List`]-`[List`](1, X@@@, |_|-`[List`](l'))
   __-`[List`]-`[List`](__-`[List`]-`[List`](X, Y), Z) -> __-`[List`]-`[List`](X, __-`[List`]-`[List`](Y, Z))
   |_|-`[List`](n) -> 1
   |_|-`[List`](nil) -> 0
   |_|-`[List`](__-`[List`]-`[List`](n, l')) -> _+_-`[List`]-`[List`](1, |_|-`[List`](l'))

Termination of R to be shown.





   R     ->Direct Termination



Direct Termination proof successful with the following AC-Compatible Recursive Path Order with Status:

Precedence:
|_|-`[List`] > _+_-`[List`]-`[List`] > _+_-`[List`]-`[List`]-`[List`]
|_|-`[List`] > 1
nil > 0


Status:
_+_-`[List`]-`[List`]: flat status
0: no status
|_|-`[List`]: no status
1: no status
nil: no status
__-`[List`]-`[List`]: [1,2]
_+_-`[List`]-`[List`]-`[List`]: no status

Removing all rules.


   R     ->Direct

       ->TRS2
         ->Dependency Pair Analysis



R contains no Dependency Pairs  and therefore no SCCs.


Termination of R successfully shown.

Duration: 
0:00 minutes



