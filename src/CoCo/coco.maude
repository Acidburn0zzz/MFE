---- ATTEMPT FOR AN INDEPENDENT COCO... moved to an integrated coco2.maude

----                                              Execution environment for CoCo
----                                                      extends Full Maude 2.7
----                                         To be run on Maude 2.7 (with hooks)
----                                                     author: Francisco Duran

load full-maude.maude
load ../CRChC/crchc3o.maude
load ../MTT/mtt.maude

fmod CoCo-BANNER is 
  pr STRING .
  op coco-banner : -> String .
  eq coco-banner = "CoCo - August 25th 2016" .
endfm

fmod CoCo-SYNTAX is
  sort <decl> <id> <idlist> <listofrules>
       <rule> <cond> <condlist> <term> <termlist> 
       <command> <conditiontype> <NeTokenList> .

  sort @Input@ .
  subsorts <decl> <command> < @Input@ .
  subsort <id> < <idlist> .

  subsort <rule> < <listofrules> .
  subsort <cond> < <condlist> .
  subsorts <id> < <term> < <termlist> .
  
  op VAR_ : <idlist> -> <decl> [gather(&)] .
  op RULES_ : <listofrules> -> <decl> [gather(&)] .
  op CONDITIONTYPE_ : <conditiontype> -> <decl> [gather(&)] .
  op COMMENT_ : <NeTokenList> -> <decl> [gather(&)] .

  ops SEMI-EQUATIONAL JOIN ORIENTED : -> <conditiontype> .

  op __ : <idlist> <idlist> -> <idlist> [assoc gather(e E)] .

  op _->_ : <term> <term> -> <rule> [gather(e e) prec 45] . 
  op _->_|_ : <term> <term> <condlist> -> <rule> [gather(e e e) prec 45] . ----- bug in MSCP
  op __ : <listofrules> <listofrules> -> <listofrules> [assoc gather(e E) prec 50] .
  
  op _`,_ : <cond> <condlist> -> <condlist> [gather(e E) prec 40] .
  op _==_ : <term> <term> -> <cond> [gather(e e) prec 37] .

  op _`(`) : <id> -> <term> [gather(e) prec 30] .
  op _`(_`) : <id> <termlist> -> <term> [gather(e &) prec 30] .
  op _`,_ : <termlist> <termlist> -> <termlist> [assoc gather(e E)] .
  
  op check : -> <command> .
  op cc : -> <command> .
endfm

fmod META-CoCo-SYNTAX is
  including META-LEVEL .
  including UNIT .

  op CoCo-BUBBLES : -> FModule .
  op CoCo-GRAMMAR : -> FModule .

  eq CoCo-BUBBLES
    = (fmod 'CoCo-GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '<id> 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`( '`) '`, '-> '== '->= '-><- '|
                                  'CONTEXTSENSITIVE 'EQUATIONS 'INNERMOST 'OUTERMOST 'RULES 'STRATEGY 'THEORY 'VAR)
                                  ))] .
        op 'neTokenList : 'QidList -> '<NeTokenList> 
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        none
        none
     endfm) .
     
  eq CoCo-GRAMMAR = addImports((including 'CoCo-SYNTAX .), CoCo-BUBBLES) .
endfm

fmod TUPLE-2{X :: TRIV, Y :: TRIV} is
  sort Tuple{X, Y} .
  op `(_`,_`) : X$Elt Y$Elt -> Tuple{X, Y} .
  op p1_ : Tuple{X, Y} -> X$Elt .
  op p2_ : Tuple{X, Y} -> Y$Elt .
  var A : X$Elt .
  var B : Y$Elt .
  eq p1(A, B) = A .
  eq p2(A, B) = B .
endfm 

view TermList from TRIV to META-LEVEL is
  sort Elt to TermList .
endv
 
view OpDeclSet from TRIV to META-LEVEL is
  sort Elt to OpDeclSet .
endv
 
view EqCondition from TRIV to META-LEVEL is
  sort Elt to EqCondition .
endv
 
fmod CoCo-UNIT-PROCESSING is
  pr UNIT-PROCESSING .
  pr TUPLE-2{TermList, OpDeclSet} * (op p1_ to getTerm, op p2_ to getOpDecls) .
  pr TUPLE-2{EqCondition, OpDeclSet} * (op p1_ to getCond, op p2_ to getOpDecls) .
  
  vars T T' T'' T''' T1 T2 T3 T4 T5 : Term .
  var  TL : TermList .
  var  DB : Database .
  var  M : Module .
  vars OPDS VDS : OpDeclSet .
  vars F V S : Qid .
  var  CT : ConditionType .
  var  Vs : QidSet .
  var  N : Nat .
  
  sort ConditionType .
  ops JOIN ORIENTED : -> ConditionType . ---- SEMI-EQUATIONAL ?
  
  op procCocoVars : Term -> QidSet .
  eq procCocoVars('__['token[T1], T2]) = downQid(T1) ; procCocoVars(T2) .
  eq procCocoVars('token[T]) = downQid(T) .
  
  op procCocoRules : Term ConditionType QidSet Module -> Module .
  eq procCocoRules('__['_->_[T, T'], T''], CT, Vs, M)
    = procCocoRules(T'', CT, Vs, 
        addEqs(eq getTerm(parseCocoTerm(T, Vs)) = getTerm(parseCocoTerm(T', Vs)) [none] ., 
          addOps(getOpDecls(parseCocoTerm(T, Vs)) getOpDecls(parseCocoTerm(T', Vs)), M))) .
  eq procCocoRules('_->_[T, T'], CT, Vs, M)
    = addEqs(eq getTerm(parseCocoTerm(T, Vs)) = getTerm(parseCocoTerm(T', Vs)) [none] ., 
        addOps(getOpDecls(parseCocoTerm(T, Vs)) getOpDecls(parseCocoTerm(T', Vs)), M)) .
  eq procCocoRules('__['_->_|_[T, T', T''], T'''], CT, Vs, M)
    = procCocoRules(T''', CT, Vs, 
        addEqs(ceq getTerm(parseCocoTerm(T, Vs)) = getTerm(parseCocoTerm(T', Vs)) if getCond(parseCocoCond(T'', CT, Vs)) [none] ., 
          addOps(getOpDecls(parseCocoTerm(T, Vs)) getOpDecls(parseCocoTerm(T', Vs)) getOpDecls(parseCocoCond(T'', CT, Vs)), M))) .
  eq procCocoRules('_->_|_[T, T', T''], CT, Vs, M)
    = addEqs(ceq getTerm(parseCocoTerm(T, Vs)) = getTerm(parseCocoTerm(T', Vs)) if getCond(parseCocoCond(T'', CT, Vs)) [none] ., 
        addOps(getOpDecls(parseCocoTerm(T, Vs)) getOpDecls(parseCocoTerm(T', Vs)) getOpDecls(parseCocoCond(T'', CT, Vs)), M)) .

  op size : TermList -> Nat .
  eq size((T, TL)) = s size(TL) .
  eq size(empty) = 0 .

  op arity : Nat -> TypeList .
  eq arity(0) = nil .
  eq arity(s N) = 'S arity(N) .

  op parseCocoTerm : Term QidSet -> Tuple{TermList, OpDeclSet} .
  eq parseCocoTerm('_`(_`)['token[T], T'], Vs) 
    = (downQid(T) [ getTerm(parseCocoTerm(T', Vs)) ], 
       op downQid(T) : arity(size(getTerm(parseCocoTerm(T', Vs)))) -> 'S [none] . getOpDecls(parseCocoTerm(T', Vs))) .
  eq parseCocoTerm('token[T], Vs) 
    = if downQid(T) in Vs 
      then (qid(string(downQid(T)) + ":S"), none) 
      else (qid(string(downQid(T)) + ".S"), op downQid(T) : nil -> 'S [none] .)
      fi .
  eq parseCocoTerm('_`,_[T, T'], Vs) 
    = ((getTerm(parseCocoTerm(T, Vs)), getTerm(parseCocoTerm(T', Vs))),
       getOpDecls(parseCocoTerm(T, Vs)) getOpDecls(parseCocoTerm(T', Vs))) .
  
  op parseCocoCond : Term ConditionType QidSet -> Tuple{EqCondition, OpDeclSet} .
  eq parseCocoCond('_`,_['_==_[T, T'], T''], CT, Vs)
    = (if CT == JOIN
       then getTerm(parseCocoTerm(T, Vs)) = getTerm(parseCocoTerm(T', Vs))
       else ---- CT == ORIENTED
            getTerm(parseCocoTerm(T', Vs)) := getTerm(parseCocoTerm(T, Vs))
       fi  
       /\ getCond(parseCocoCond(T'', CT, Vs)),
       getOpDecls(parseCocoTerm(T, Vs)) 
       getOpDecls(parseCocoTerm(T', Vs))
       getOpDecls(parseCocoCond(T'', CT, Vs))) .
  eq parseCocoCond('_==_[T, T'], CT, Vs)
    = (if CT == JOIN
       then getTerm(parseCocoTerm(T, Vs)) = getTerm(parseCocoTerm(T', Vs))
       else ---- CT == ORIENTED
            getTerm(parseCocoTerm(T', Vs)) := getTerm(parseCocoTerm(T, Vs))
       fi,
       getOpDecls(parseCocoTerm(T, Vs)) 
       getOpDecls(parseCocoTerm(T', Vs))) .
endfm

mod CoCo-DATABASE-HANDLING is
  inc DATABASE-HANDLING .
  inc CoCo-UNIT-PROCESSING .
  inc CONFLUENCE-CHECK . 
  inc MTT-TOOL .
  
  sort CoCoDatabaseClass .
  subsort CoCoDatabaseClass < DatabaseClass .
  op CoCoDatabase : -> CoCoDatabaseClass .
  op module`:_ : Module -> Attribute .
  op condition-type`:_ : ConditionType -> Attribute .
  op vars`:_ : QidSet -> Attribute .
  
  vars O : Oid .
  vars T : Term .
  var  TL : TermList .
  vars F : Qid .
  vars ME : ModuleExpression .
  vars DB : Database .
  vars Atts : AttributeSet .
  var  X@CoCoDatabaseClass : CoCoDatabaseClass .
  var  QIL : QidList .
  var  M : Module .
  var  CT : ConditionType .
  var  Vs : QidSet .
    
  rl [CoCo-condition-type] :
     < O : X@CoCoDatabaseClass | input : ('CONDITIONTYPE_['ORIENTED.<conditiontype>]), condition-type : CT, Atts >
     => < O : X@CoCoDatabaseClass | input : nilTermList, condition-type : ORIENTED, Atts > .
  rl [CoCo-condition-type] :
     < O : X@CoCoDatabaseClass | input : ('CONDITIONTYPE_['JOIN.<conditiontype>]), condition-type : CT, Atts >
     => < O : X@CoCoDatabaseClass | input : nilTermList, condition-type : JOIN, Atts > .

  rl [CoCo-vars] :
     < O : X@CoCoDatabaseClass | input : ('VAR_[T]), vars : Vs, Atts >
     => < O : X@CoCoDatabaseClass | input : nilTermList, vars : procCocoVars(T), Atts > .

  rl [CoCo-rules] :
     < O : X@CoCoDatabaseClass | input : ('RULES_[T]), condition-type : CT, vars : Vs, module : M, Atts >
     => < O : X@CoCoDatabaseClass | input : nilTermList, condition-type : CT, vars : Vs, 
            module : procCocoRules(T, CT, Vs, M), Atts > .
        
  rl [CoCo-comment] :
     < O : X@CoCoDatabaseClass | input : ('COMMENT_[T]), Atts >
     => < O : X@CoCoDatabaseClass | input : nilTermList, Atts > .
        
  rl [CoCo-commands] :
     < O : X@CoCoDatabaseClass | input : ('check.<command>), output : QIL, module : M, Atts >
     => < O : X@CoCoDatabaseClass | 
           input : nilTermList, 
           output : if substr(terminationCheck(M, C;A;B(no-sorts), false, false, "aprove"), 0, 3) == "YES"
                    then if pendingCPs(confluenceCheck(M)) == none then 'yes else 'no fi
                    else 'no '\n 
                         if substr(terminationCheck(M, C;A;B(no-sorts), false, false, "aprove"), 0, 2) == "NO"
                         then 'The 'specification 'has 'been 'proven 'non-terminating 'using 'AProVE
                         else 'The 'termination 'of 'the 'specification 'has 'not 'been 'proven
                         fi
                    fi, 
           module : M, Atts > . 
endm

mod CoCo is
  pr META-CoCo-SYNTAX .
  pr CoCo-DATABASE-HANDLING .
  inc LOOP-MODE .
  pr CoCo-BANNER .

  subsort Object < State .

  op o : -> Oid .
  op init : -> System .

  var  Atts : AttributeSet .
  var  X@CoCoDatabaseClass : CoCoDatabaseClass .
  var  X@DatabaseClass : DatabaseClass .
  var  O : Oid .
  var  DB : Database .
  var  ME : Header .
  var  QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  N : Nat .
  vars RP RP' : ResultPair .

  rl [init] :
     init
     => [nil,
         < o : CoCoDatabase | 
            db : initialDatabase,
            input : nilTermList, output : nil, 
            default : 'CONVERSION, 
            module : addSorts('S ; 'Bool, 
                       addOps(
                         op 'false : nil -> 'Bool [ctor special(id-hook('SystemFalse, nil))] .
                         op 'true : nil -> 'Bool [ctor special(id-hook('SystemTrue, nil))] ., 
                         emptyFModule('CoCoModule))),
            condition-type : JOIN,
            vars : none >,
         nil ---- ('\n '\t '\s '\s '\s '\s string2qidList(coco-banner) '\n)
         ] .

  rl [in] :
    [QI QIL, 
     < O : X@CoCoDatabaseClass | 
         db : DB, input : nilTermList, output : nil, default : ME, Atts >, 
     QIL']
    => if metaParse(CoCo-GRAMMAR, QI QIL, '@Input@) :: ResultPair
       then [nil, 
             < O : X@CoCoDatabaseClass | db : DB, 
                 input : getTerm(metaParse(CoCo-GRAMMAR, QI QIL, '@Input@)),
                 output : nil, default : ME, Atts >, 
              QIL'] 
       else [nil, 
             < O : X@CoCoDatabaseClass | db : DB, input : nilTermList, 
                 output : ('\r 'Warning: 
                           printSyntaxError(metaParse(CoCo-GRAMMAR, QI QIL, '@Input@), 
                             QI QIL) 
                           '\n
                           '\r 'Error: '\o 'No 'parse 'for 'input. '\n), 
                 default : ME, Atts >, 
             QIL'] 
       fi .

  rl [out] :
    [QIL, 
     < O : X@DatabaseClass | 
         db : DB, input : TL, output : (QI QIL'), default : ME, Atts >, 
     QIL'']
    => [QIL, 
        < O : X@DatabaseClass | 
            db : DB, input : TL, output : nil, default : ME, Atts >, 
        (QI QIL' QIL'')] .
endm

loop init .
