---- Things to be fixed:
---- - ChC ground case: Derived operators are frozen, but only those with different 
----   syntactic form should be frozen. Notice that subsort overloded operators 
----   must have the same attributes.
---- - The proof obligation returned by the ChC should be in the syntax of the ITP.
---- - The A case should be improved. Currently, each of the associative (without comm)
----   operators are eliminated by adding a non-problematic orientation of the 
----   corresponding associativity equation. We however may be not handling cases 
----   that could be handled, since the orientation chosen for an operator may 
----   make invalid both the orientations of the equation for other associative 
----   operators considered later. Instead of dealing with them one after another, 
----   we should consider all the possible orientations of the equations for all the 
----   (only) associative operators in our spec.  
---- - The AU case does not work. The equations being added (together with the 
----   variants of the axioms) to eliminate the identities unify with both orientations
----   of the associative case. It is not enough with checking if there is a 
----   narrowing step, but we can check whether the oriented associativity rule
----   is coherent with the equations in the module. That is, we basically look 
----   for narrowing steps, but discard as unproblematic those which give place
----   to critical pairs that can be closed. 
----   The case of coherence is a bit more subtle, so it be happening that the 
----   equational part was proved confluent using a particular orientation of the 
----   associativity rule, and therefore we need to make sure that the same orientation
----   is used for the coherence check. What would need to be done is to do one check 
----   after the other, and proceed with the coherence check once confluence has 
----   been proved using the exact module used in the process. I will have to 
----   see how to modify the confluence check so that the funtion returns both the 
----   critical pairs and the module resulting from the transformations used.     

-------------------------------------------------------------------------------
---- file: crchc3j.maude
---- author: Francisco Duran
---- last modified by Francisco Duran on October 27th, 2010
----
---- use: load it in Maude (alpha 95) after Full Maude (full-maude25a.maude)
----      maude full-maude crchc3j
----
---- commands available:
----      - (help .)
----        shows the commands available
----
----      - (check Church-Rosser .)
----        checks the Church-Rosser property of the default module.
----      - (check Church-Rosser <module> .)
----        checks the Church-Rosser property of the specified module.
----      - (show CRC critical pairs .)  
----        shows the cps of the last check Church-Rosser command after rewritten
----      - (show all CRC critical pairs .)  
----        shows the cps of the last check Church-Rosser command before rewritten
----
----      - (check coherence .)
----        checks the coherence property of the default module.
----      - (check coherence <module> .)
----        checks the coherence property of the specified module.
----      - (check ground coherence .)
----        checks the coherence property of the default module (with all defined operations frozen).
----      - (check ground coherence <module> .)
----        checks the coherence property of the specified module (with all defined operations frozen).
----      - (show ChC critical pairs .)  
----        shows the cps of the last check coherence command after rewritten
----      - (show all ChC critical pairs .)  
----        shows the cps of the last check coherence command before rewritten
----
---- main changes and bugs fixed since last release:
---- 
---- - October 27th, 2010
----   - The discarding of cps by unfeasibility and context joinability has been improved.
----     - Un feasibility has been extended to cover the case of conditions like true = false.
----       In a preunfeasibility process conditions are evaluated without the context given by
----       the conditions. If the terms of a equality condition do not have variables, are 
----       strongly irreducible and are different (non unifiable), then the condition is not 
----       satisfiable.  
----     - For the ChC conditions are simplified.
----     - In the ChC ground case, an inductive proof obligation is now generated.  
---- - December 7th, 2009
----   - Several problems with the getVariants function fixed by Santiago Escobar. 
----   - The A without C case now supported by using the techniques in FroCos'09.
----   - The U case is now handled by using the variant-based transformation in FroCos'09.
---- - November 5th, 2009
----   - added a function that calculates the closure of a set (closure : Sort Module -> Set{Sort})
---- - October 2009
----   - Ids are removed using the variant-based transformation (removeIds).  
----     The metaNarrowSearch function is used instead of metaNarrowSearchGenAll.
---- - July, 20th
----   - We now support LU, RU, C, CU, AC and ACU cases.
----   - A message is given if the speficication to be checked does not satisfy the requirements
----     (use of iter, idem, owise, assoc without comm, or special, i.e. built-ins, or use of equations or 
----     rules with single variables in their left-hand sides)
----   - Some conditional critical pairs can now be discarded by checking their context-joinability
----     and unfeasibility.
---- - July 24th
----   - Axioms with non-exec attributes are not taken into account by the tools 

---- to do:
---- - Reglas AC-coherentes para poder utilizar narrowing
---- - en chc add rl-eq
---- - el coherence check utiliza simplify, el findAllOneStepRewrites no funciona
---- - comando check ground coherence
---- - check coherence deber’a hacer frozen todos los operadores deinidos, 
----   check ground coherence no hace congeladas las cosas definidas
---- - documentar los ctor-split
---- - a–adir comandos check lcoherence y check ground lcoherence
----   funciona igual, pero al buscar se utilizan solo las reglas con la misma 
----   etiqueta de la utilizada en el par cr’tico (ver notas murcia 26-27/12/08)
---- - for conditional case, a manual search is required 

----load ../FM24/full-maude24l.maude

fmod CRC-BANNER is
  pr STRING .
  op crc-banner : -> String .
  eq crc-banner = "Church-Rosser Checker 3j - October 27th 2010" .
endfm

fmod CHC-BANNER is
  pr STRING .
  op chc-banner : -> String .
  eq chc-banner = "Coherence Checker 3j - October 27th 2010" .
endfm

fmod DEBUGGING is
  op debugging : -> Bool .
  eq debugging = false . ----- set it to true if you want to see why ccps are discarded
endfm   

fmod CRC-HELP is
  pr HELP .
  pr EXT-QID-LIST .
  op crc-help : -> QidList .
  eq crc-help 
    = ----help 
      string2qidList("Commands available in the CRC tool:") '\n
      '\t string2qidList("(check Church-Rosser .)") '\n
      '\t '\t string2qidList("checks the Church-Rosser property of the default module.") '\n
      '\t string2qidList("(check Church-Rosser <module> .)") '\n
      '\t '\t string2qidList("checks the Church-Rosser property of the specified module.") '\n
      ----'\t string2qidList("(check coherence .)") '\n
      ----'\t '\t string2qidList("checks the coherence property of the default module.") '\n
      ----'\t string2qidList("(check coherence <module> .)") '\n
      ----'\t '\t string2qidList("checks the coherence property of the specified module.") '\n
      '\t string2qidList("(show CRC critical pairs .)") '\n
      '\t '\t string2qidList("shows the cps of the last check Church-Rosser command after rewritten.") '\n
      '\t string2qidList("(show all CRC critical pairs .)") '\n
      '\t '\t string2qidList("shows the cps of the last check Church-Rosser command before rewritten.") .
endfm

fmod CHC-HELP is
  pr HELP .
  pr EXT-QID-LIST .
  op chc-help : -> QidList .
  eq chc-help 
    = ----help 
      string2qidList("Commands available in the ChC tool:") '\n
      '\t string2qidList("(check coherence .)") '\n
      '\t '\t string2qidList("checks the coherence property of the default module.") '\n
      '\t string2qidList("(check coherence <module> .)") '\n
      '\t '\t string2qidList("checks the coherence property of the specified module.") '\n
      '\t string2qidList("(check ground coherence .)") '\n
      '\t '\t string2qidList("checks the ground coherence property of the default module.") '\n
      '\t string2qidList("(check ground coherence <module> .)") '\n
      '\t '\t string2qidList("checks the ground coherence property of the specified module.") '\n
      '\t string2qidList("(show ChC critical pairs .)") '\n
      '\t '\t string2qidList("shows the critical pairs of the last check coherence or ground coherence command after rewritten.") '\n
      '\t string2qidList("(show all ChC critical pairs .)") '\n
      '\t '\t string2qidList("shows the critical pairs of the last check coherence or ground coherence command before rewritten.") .
endfm

---- main changes from 3d:
---- - May 13th, 2009
----   Most general critical pairs calculation failed for conditional cps with different number of conditions. 
----      - uses narrowing to generated the critical pairs (based on work by S. 
----      - Escobar et al.)  
----      - keeps the cps in the state of the database, both before and after 
----        rewriting them, so that we can later refer to them.
----      - a new command (show critical pairs .) shows the cps after rewritten
----      - a new command (show all critical pairs .) shows the cps before rewritten
---- to do:
----      - add a command (ctor-split n on x .) where n is the goal number (the 
----        unjoined cp with number n, and x is the variable to instantiate 
----        with constructor terms.  
-------------------------------------------------------------------------------

set show loop stats off .
set show loop timing off .
----set show advisories off .

**** We first introduce some basic functions for the manipulation of terms, and 
**** then we present the unification and matching functions.

fmod AUXILIARY-FUNCTIONS is
  pr UNIT .
  pr EXT-BOOL .
  pr EXT-DECL .
  pr EXT-TERM .
  pr INT .

  vars T T' : Term .
  var  TL : TermList .
  vars Tp Tp' Tp'' Tp''' : Type .
  vars TpL TpL' : TypeList .
  vars M M' M'' : Module .
  var  At : Attr .
  var  AtS : AttrSet .
  vars L F G : Qid .
  var  QIL : QidList .
  var  ODS : OpDeclSet .
  var  EqS : EquationSet .
  var  Cd : EqCondition .
  var  S : Sort .
  var  Mb : MembAx .
  var  MbS : MembAxSet .
  var  RlS : RuleSet .

  *** some built-in sort operations on lists
  op sortLeq : Module TypeList TypeList ~> Bool [ditto] . 
  eq sortLeq(M, (Tp Tp' TpL), (Tp'' Tp''' TpL')) 
    = sortLeq(M, Tp, Tp'') and-then sortLeq(M, Tp' TpL, Tp''' TpL') .
  eq sortLeq(M, nil, nil) = true .  
  eq sortLeq(M, TpL, TpL') = false [owise] .
  
  op sameKind : Module TypeList TypeList ~> Bool [ditto] . 
  eq sameKind(M, (Tp Tp' TpL), (Tp'' Tp''' TpL')) 
    = sameKind(M, Tp, Tp'') and-then sameKind(M, Tp' TpL, Tp''' TpL') .
  eq sameKind(M, nil, nil) = true .  
  eq sameKind(M, TpL, TpL') = false [owise] .

  op leastSort : Module TermList ~> TypeList [ditto] .
  eq leastSort(M, (T, T', TL)) = leastSort(M, T) leastSort(M, (T', TL)) .
  eq leastSort(M, empty) = nil .
  
  op getLabel : AttrSet -> Qid .
  eq getLabel(label(L) AtS) = L .
  eq getLabel(AtS) = 'no-label [owise] .

  **** hasAttr checks whether the given operator has the given attribute
  **** in its declaration in the given module

  op hasAttr : Module Qid TypeList Attr -> Bool .
  op hasAttr : Module OpDeclSet Qid TypeList Attr -> Bool .

  eq hasAttr(M, G, TpL, At) = hasAttr(M, getOps(M), G, TpL, At) .
  eq hasAttr(M, op F : TpL -> Tp [AtS] . ODS, G, TpL', At) 
    = if (F == G) and-then sameKind(M, TpL, TpL')
      then At in AtS
      else hasAttr(M, ODS, G, TpL', At)
      fi .
  eq hasAttr(M, none, G, TpL, At) = false .

endfm

fmod MATCHING is
  pr UNIT .

  op metaMatch : Module EquationSet ~> Bool .

  var  M : Module .
  var  EqS : EquationSet .
  vars T T' : Term .
  vars TL TL' : TermList .

  eq metaMatch(M, eq T = T' [none] . EqS) 
    = metaMatch(M, T, T', nil, 0) =/= noMatch and-then metaMatch(M, EqS) .
  eq metaMatch(M, none) = true . 
endfm

fmod CRITICAL-PAIR is
  pr EXT-TERM .
  pr MATCHING .
  pr DECL-META-PRETTY-PRINT .

  sort CritPair .
  op cp : Qid Qid Term Term -> CritPair .
  op ccp : Qid Qid Term Term Condition -> CritPair .
  ops lhs rhs : CritPair -> Term .
  eq lhs(cp(L, L', T, T')) = T .
  eq lhs(ccp(L, L', T, T', Cd)) = T .
  eq rhs(cp(L, L', T, T')) = T' .
  eq rhs(ccp(L, L', T, T', Cd)) = T' .

  sort CritPairSet .
  subsort CritPair < CritPairSet .
  op none : -> CritPairSet .
  op __ : CritPairSet CritPairSet -> CritPairSet [assoc comm id: none] .

  vars T T' T'' T''' T1 T1' T1'' T1''' T2 T2' T2'' T2''' : Term .
  vars L L' L1 L1' L2 L2' QI : Qid .
  var  CP CP' : CritPair .
  vars CPS CPS' : CritPairSet .
  var  M : Module .
  vars Cd Cd1 Cd2 : EqCondition .
  var  S : Sort .
  var  Subst : Substitution .
  var  QIL : QidList .

  eq CP CP = CP .

  op delete : CritPairSet -> CritPairSet .

  eq delete(cp(L, L', T, T') CPS)
    = if T == T'
      then delete(CPS)
      else cp(L, L', T, T') delete(CPS)
      fi .
  eq delete(ccp(L, L', T, T', Cd) CPS)
    = if T == T'
      then delete(CPS)
      else ccp(L, L', T, T', Cd) delete(CPS)
      fi .
  eq delete(none) = none .

  op simplify : CritPairSet Module -> CritPairSet .
  eq simplify(cp(L, L', T, T') CPS, M)
    = cp(L, L', getTerm(metaReduce(M, T)), getTerm(metaReduce(M, T')))
      simplify(CPS, M) .
  eq simplify(ccp(L, L', T, T', Cd) CPS, M)
    = ccp(L, L', getTerm(metaReduce(M, T)), getTerm(metaReduce(M, T')), Cd)
      simplify(CPS, M) .
  eq simplify(none, M) = none .

  op maximalCPSet : CritPairSet Module -> CritPairSet .
  op maximalCPSetAux : CritPair CritPairSet CritPairSet Module -> CritPairSet .
  op moreGeneralCP : CritPair CritPair Module -> Bool .

  eq maximalCPSet(CP CPS, M)
    = maximalCPSetAux(CP, CPS, none, M) .
  eq maximalCPSet(none, M) = none .

  eq maximalCPSetAux(CP, CP' CPS, CPS', M)
    = if moreGeneralCP(CP, CP', M)
      then maximalCPSetAux(CP, CPS, CPS', M)
      else if moreGeneralCP(CP', CP, M)
           then maximalCPSetAux(CP', CPS CPS', none, M)
           else maximalCPSetAux(CP, CPS, CP' CPS', M)
           fi
      fi .
  eq maximalCPSetAux(CP, none, CP' CPS, M)
    = CP maximalCPSetAux(CP', CPS, none, M) .
  eq maximalCPSetAux(CP, none, none, M) = CP .

  eq moreGeneralCP(cp(L1, L1', T1, T1'), cp(L2, L2', T2, T2'), M)
    = metaMatch(M, ((eq T1 = T2 [none].) (eq T1' = T2' [none].)))
      or-else
      metaMatch(M, ((eq T1 = T2' [none] .) (eq T1' = T2 [none] .))) .
  eq moreGeneralCP(cp(L1, L1', T1, T1'), ccp(L2, L2', T2, T2', Cd2), M)
    = metaMatch(M, ((eq T1 = T2 [none].) (eq T1' = T2' [none] .)))
      or-else
      metaMatch(M, ((eq T1 = T2' [none] .) (eq T1' = T2 [none] .))) .
  eq moreGeneralCP(ccp(L1, L1', T1, T1', Cd1), cp(L2, L2', T2, T2'), M)
    = false .
  eq moreGeneralCP(ccp(L1, L1', T1, T1', Cd1), 
                   ccp(L2, L2', T2, T2', Cd2), M)
    = metaMatch(M, ((eq T1 = T2 [none].) (eq T1' = T2' [none].) mgcpme(Cd1, Cd2)))
      or-else
      metaMatch(M, ((eq T1 = T2' [none].) (eq T1' = T2 [none].) mgcpme(Cd1, Cd2))) .

  op mgcpme : EqCondition EqCondition -> EquationSet .
  eq mgcpme(T1 = T1' /\ Cd1, T2 = T2' /\ Cd2) 
    = ((eq T1 = T2 [none] .) (eq T1' = T2' [none] .) mgcpme(Cd1, Cd2)) .
  eq mgcpme(T1 := T1' /\ Cd1, T2 := T2' /\ Cd2) 
    = ((eq T1 = T2 [none] .) (eq T1' = T2' [none] .) mgcpme(Cd1, Cd2)) .
  eq mgcpme(T1 : S /\ Cd1, T2 : S /\ Cd2) 
    = ((eq T1 = T2 [none] .) mgcpme(Cd1, Cd2)) .
  eq mgcpme(nil, nil) = none .
  eq mgcpme(Cd1, Cd2) = (eq 'true.Bool = 'false.Bool [none] .) [owise] . ----- This is too restrictive. 

  op eMetaPrettyPrint : Module Qid CritPairSet -> QidList .

  eq eMetaPrettyPrint(M, QI, cp(L, L', T, T') CPS)
    = ('\n '\s '\s '\b 'cp '\o
       (if L =/= 'no-label and L' =/= 'no-label 
        then '\b 'for '\o L '\b 'and '\o L' '\n '\s '\s '\s 
        else nil
        fi)
       '\s metaPrettyPrint(M, T) 
       '\n '\s '\s '\s '\s QI '\o metaPrettyPrint(M, T') '. '\o 
       eMetaPrettyPrint(M, QI, CPS)) .
  eq eMetaPrettyPrint(M, QI, ccp(L, L', T, T', Cd) CPS)
    = ('\n '\s '\s '\b 'ccp '\o
       (if L =/= 'no-label and L' =/= 'no-label 
        then '\b 'for '\o L '\b 'and '\o L' '\n '\s '\s '\s
        else nil
        fi)
       '\s metaPrettyPrint(M, T) 
       '\n '\s '\s '\s '\s '\b QI '\o metaPrettyPrint(M, T') 
       '\n '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cd) '\b '. '\o 
       eMetaPrettyPrint(M, QI, CPS)) .
  eq eMetaPrettyPrint(M, QI, (none).CritPairSet) = nil .
  eq eMetaPrettyPrint(unitError(QIL), QI, CPS:[CritPairSet]) = QIL .
endfm

view CritPairSet from TRIV to CRITICAL-PAIR is
  sort Elt to CritPairSet .
endv

--------------------------------------------------------------------------------
---- Context-Joinability and Unfeasible Conditional Critical Pairs
--------------------------------------------------------------------------------
---- 
---- Suppose that you get a nontrivial \emph{conditional critical pair} of the form:
---- $$ (u_1=v_1\wedge\ldots\wedge u_k=v_k\wedge v_{k+1}:=u_{k+1}\wedge\ldots\wedge v_{k+r}:=u_{k+r}) \Rightarrow t=t'$$
---- 
---- \noindent (of course the \emph{order} of ordinary and matching equations can be \emph{mixed}.)
---- 
---- Perform the following transformation:
---- 
---- \renewcommand{\labelenumi}{(\alph{enumi})}
---- \begin{enumerate}
---- \item Any $v_{i}:=u_{i}$ becomes a condition $u_i\rightarrow v_i$.
---- \item Any $u_{i}=v_{i}$ where, say, $v_i$ is a \emph{ground term in canonical form} becomes $u_i\rightarrow v_i$.
---- \item For all other $u_{i}:=v_{i}$ introduce a \emph{fresh new variable} $x_i$ of the smallest of the sorts of $u_i$ and $v_i$ 
---- so that the rules are \emph{sort decreasing},\footnote{If the sorts are not comparable, then pick one of those sorts 
---- non-deterministically. Or if $lub(ls(u_i),ls(v_i)$ is singleton, then pick $lnb$.} and \emph{two conditions} $u_i\rightarrow x_i$ 
---- and $v_i\rightarrow x_i$.
---- \end{enumerate}
---- 
---- Call $C$ the new condition so obtained, and $X$ the \emph{variables} in $C$ and $t$ and $t'$. Get the new $CCP$.
---- 
---- To check whether the CCP is \emph{context joinable}:
---- 
---- \renewcommand{\labelenumi}{(\roman{enumi})}
---- \begin{enumerate}
---- \item Add the new variables $x$ as constants $\overline{X}$.
---- \item Add to the rules $R$ the new \emph{ground} rewrite rules $\overline{C}$ plus an equality operator $eq$ with rules 
---- $eq(x,x)\rightarrow tt$. Call this theory $\hat{\cR}_{\overline{C}}$.
---- \item In $\hat{\cR}_{\overline{C}}$, search $eq(\overline{t},\overline{t'})\Rightarrow ^{+} tt$ up to some predetermined 
---- depth (using the \verb#search# command).
---- \end{enumerate}
---- 
---- If the search is successful, then the CCP is context joinable. 

fmod CRC-CONTEXT-JOINABILITY-UNFEASIBILITY is
  pr CRITICAL-PAIR .
  pr 2TUPLE{RuleSet, OpDeclSet} * (op p1_ to getRls, op p2_ to getOps) .
  pr 2TUPLE{TermList, OpDeclSet} * (op p1_ to getTerms, op p2_ to getOps) .
  pr 2TUPLE{QidSet, Condition} * (op p2_ to getCondition, op p1_ to getVars) .
  pr META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) . 
  pr DEBUGGING .
  
  op joinability-depth : -> Nat .
  eq joinability-depth = 10 .

  vars QI QI' F : Qid .
  var  VS : QidSet .
  var  V : Variable .
  var  Ct : Constant .
  vars T T' T'' T''' : Term .
  vars TL TL' : TermList .
  var  TS : TermSet .
  vars Cd Cd' : Condition .
  var  N : Nat .
  vars M M' M'' : Module .
  var  Tp : Type .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  CP : CritPair .
  var  CPS : CritPairSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  RlS : RuleSet .
  var  S : Sort .
  var  K : Kind .
  var  KS : KindSet .
  var  DEBUGGING : Bool .
    
  op crcRemoveContextJoinableAndUnfeasibleCPs : Module CritPairSet -> CritPairSet .
  op crcContextJoinable : Module Term Term -> Bool .
  op unfeasible : Module Module Module Condition -> Bool .

  eq crcRemoveContextJoinableAndUnfeasibleCPs(M, CP CPS) 
    = if crcRemovable(M, CP)
      then crcRemoveContextJoinableAndUnfeasibleCPs(M, CPS)
      else CP crcRemoveContextJoinableAndUnfeasibleCPs(M, CPS)
      fi .
  eq crcRemoveContextJoinableAndUnfeasibleCPs(M, none) = none .
  
  op crcRemovable : Module CritPair -> Bool .
  op crcRemovable : Module CritPair Bool -> Bool .
  op $crcRemovable : Module CritPair Bool -> Bool .
  
  eq crcRemovable(M, CP) = crcRemovable(M, CP, debugging) .

  eq crcRemovable(M, cp(QI, QI', T, T'), DEBUGGING) = false .  ---- not debugging
  eq crcRemovable(M, ccp(QI, QI', T, T', Cd), DEBUGGING)
    = preunfeasible(M, Cd) or-else $crcRemovable(M, ccp(QI, QI', T, T', Cd), DEBUGGING) .
    
 ceq $crcRemovable(M, ccp(QI, QI', T, T', Cd), false)
    = crcContextJoinable(M'', getTerms(vars2cts(T)), getTerms(vars2cts(T')))
      or-else
      unfeasible(M, M', M'', Cd')
    if Cd' := transform(M, Cd)            ---- new CCP
    /\ M' := rulify(M)                    ---- turns equations into rules, and equational conditions into rewrites              
    /\ M'' := addRls(                     ---- $\hat{\cR}_{\overline{C}}$
               (getRls(groundRls(Cd'))
                equalRls(getKinds(M))),
               addOps(
                 (op 'tt : nil -> '`[Thruth`] [none] .
                  equalOps(getKinds(M))
                  getOps(groundRls(Cd'))
                  getOps(vars2cts(T))
                  getOps(vars2cts(T'))), 
                 addSorts('Thruth, M'))) .                  

  vars CONTEXT-JOINABLE UNFEASIBLE : Bool .
  op $crcRemovableAux : Module CritPair Module Module Condition Bool Bool -> Bool .

 ceq $crcRemovable(M, ccp(QI, QI', T, T', Cd), true)
    = $crcRemovableAux(M, ccp(QI, QI', T, T', Cd), M', M'', Cd', CONTEXT-JOINABLE, UNFEASIBLE)
    if Cd' := transform(M, Cd)            ---- new CCP
    /\ M' := rulify(M)                    ---- turns equations into rules, and equational conditions into rewrites
    /\ M'' := addRls(                     ---- $\hat{\cR}_{\overline{C}}$
               (getRls(groundRls(Cd'))
                equalRls(getKinds(M))),
               addOps(
                 (op 'tt : nil -> '`[Thruth`] [none] .
                  equalOps(getKinds(M))
                  getOps(groundRls(Cd'))
                  getOps(vars2cts(T))
                  getOps(vars2cts(T'))), 
                 addSorts('Thruth, M')))
    /\ CONTEXT-JOINABLE := crcContextJoinable(M'', getTerms(vars2cts(T)), getTerms(vars2cts(T')))
    /\ UNFEASIBLE := unfeasible(M, M', M'', Cd') .
 
  eq $crcRemovableAux(M, ccp(QI, QI', T, T', Cd), M', M'', Cd', CONTEXT-JOINABLE, UNFEASIBLE)
    = CONTEXT-JOINABLE or-else UNFEASIBLE 
    ---- [print "cp[" QI "," QI' "]: " T " = " T' " if " Cd] .                  
    [print "cp[" QI "," QI' "]: " T " = " T' " if " Cd " c-j: " CONTEXT-JOINABLE " u: " UNFEASIBLE] .                  
                  
  eq crcContextJoinable(M, T, T')
    = metaSearch(M, 'equal[T, T'], 'tt.`[Thruth`], nil, '+, joinability-depth, 0) =/= failure .

  op preunfeasible : Module Condition -> Bool .
  eq preunfeasible(M, T = T' /\ Cd)
    = if ---- ground irreducible distinct terms 
         vars(T) == none and-then getTerm(metaNormalize(M, T)) == getTerm(metaReduce(M, T))
         and-then
         vars(T') == none and-then getTerm(metaNormalize(M, T')) == getTerm(metaReduce(M, T'))
         and-then T =/= T'
      then true
      else preunfeasible(M, Cd)
      fi .
  eq preunfeasible(M, T => T' /\ Cd) = preunfeasible(M, Cd) .
  eq preunfeasible(M, T : S /\ Cd) = preunfeasible(M, Cd) .
  eq preunfeasible(M, T := T' /\ Cd) = preunfeasible(M, Cd) .
  eq preunfeasible(M, nil) = false .

  eq unfeasible(M, M', M'', T => T' /\ Cd)
    = ---- if T' :: Variable 
      ---- then unfeasible(M, M', M'', Cd)
      ---- else 
           if | searchNormalForms(M'', getTerms(vars2cts(T)), leastSort(M, T), 0) | <= 1 
           then unfeasible(M, M', M'', Cd) 
           else checkUnfeasibility(M', restoreVars(searchNormalForms(M'', getTerms(vars2cts(T)), leastSort(M, T), 0))) 
                or-else
                unfeasible(M, M', M'', Cd)
           fi
      ---- fi 
      .
  eq unfeasible(M, M', M'', nil) = false . 
  
  op restoreVars : TermSet -> TermSet . ---- new vars start with ##
  op restoreVarsAux : TermList -> TermList .
  eq restoreVars(T | TS) = restoreVarsAux(T) | restoreVars(TS) .
  eq restoreVars(emptyTermSet) = emptyTermSet .
  eq restoreVarsAux((V, TL)) = (V, restoreVarsAux(TL)) .
  eq restoreVarsAux((Ct, TL)) 
    = if substr(string(Ct), 0, 2) == "##"
      then qid(substr(string(getName(Ct)), 2, _-_(length(string(getName(Ct))), 2)) + ":" + string(getType(Ct)))
      else Ct
      fi,
      restoreVarsAux(TL) .
  eq restoreVarsAux((F[TL], TL')) = (F[restoreVarsAux(TL)], restoreVarsAux(TL')) .
  eq restoreVarsAux(empty) = empty .
               
  op searchNormalForms : Module Term Type Nat -> TermSet .
  eq searchNormalForms(M, T, Tp, N)
    = if metaSearch(M, T, qid("X:" + string(Tp)), nil, '!, joinability-depth, N) =/= failure
      then getTerm(metaSearch(M, T, qid("X:" + string(Tp)), nil, '!, joinability-depth, N))
           | searchNormalForms(M, T, Tp, s N)
      else emptyTermSet
      fi .

  op checkUnfeasibility : Module TermSet -> Bool .
  op checkUnfeasibility : Module Term TermSet -> Bool .

  eq checkUnfeasibility(M, T | TS) = checkUnfeasibility(M, T, TS) or-else checkUnfeasibility(M, TS) . 
  eq checkUnfeasibility(M, emptyTermSet) = false .

  eq checkUnfeasibility(M, T, T' | TS)
    = if metaACUUnify(M, T, T') == empty ---- no unifiers in common... only C, LU, RU, CU, and ACU
         and-then (strongly-irreducible(M, T) and-then strongly-irreducible(M, T')) 
      then true
      else checkUnfeasibility(M, T, TS)
      fi .
  eq  checkUnfeasibility(M, T, emptyTermSet) = false .
  
  op strongly-irreducible : Module Term -> Bool .
  eq strongly-irreducible(M, T) 
    = metaNarrowSearch(M, T, qid("X:" + string(leastSort(M, T))), none, '+, 1, 1) == empty . 
  ----eq strongly-irreducible(M, T) 
  ----  = metaNarrowSearchGenAll(
  ----           M, 
  ----           T,
  ----           qid("X:" + string(leastSort(M, T))), 
  ----           none, '+, 1, 1, full E-ACU-unify noStrategy) == empty . 

  op groundRls : Condition -> Tuple{RuleSet, OpDeclSet} .
  op groundRls : Condition RuleSet OpDeclSet -> Tuple{RuleSet, OpDeclSet} .
  eq groundRls(Cd) = groundRls(Cd, none, none) .
  eq groundRls(T => T' /\ Cd, RlS, ODS) 
    = groundRls(Cd, rl getTerms(vars2cts(T)) => getTerms(vars2cts(T')) [none] . RlS, getOps(vars2cts(T)) getOps(vars2cts(T')) ODS) .
  eq groundRls(Cd, RlS, ODS) = (RlS, ODS) [owise] .
  
  op transform : Module Condition -> Condition .
  op transform : Module Condition Nat -> Condition .
  
  eq transform(M, Cd) = transform(M, Cd, 0) .
  eq transform(M, T = T' /\ Cd, N) 
    = if ---- T is irreducible but T' isn't
         vars(T) == none and-then getTerm(metaNormalize(M, T)) == getTerm(metaReduce(M, T))
         and-then
         not (vars(T') == none and-then getTerm(metaNormalize(M, T')) == getTerm(metaReduce(M, T')))
      then T' => T /\ transform(M, Cd, N)
      else if ---- T' is irreducible but T isn't
              not (vars(T) == none and-then getTerm(metaNormalize(M, T)) == getTerm(metaReduce(M, T)))
              and-then
              vars(T') == none and-then getTerm(metaNormalize(M, T')) == getTerm(metaReduce(M, T'))
           then T => T' /\ transform(M, Cd, N)  
           else ---- either none or both of them are irreducible
                if | glbSorts(M, leastSort(M, T), leastSort(M, T')) | == 1
                then T => qid("@X@" + string(N, 10) + ":" + string(glbSorts(M, leastSort(M, T), leastSort(M, T')))) 
                     /\ T' => qid("@X@" + string(N, 10) + ":" + string(glbSorts(M, leastSort(M, T), leastSort(M, T'))))
                     /\ transform(M, Cd, s N) 
                else T => qid("@X@" + string(N, 10) + ":" + string(leastSort(M, T))) ---- should we use the kind instead of one of them?
                     /\ T' => qid("@X@" + string(N, 10) + ":" + string(leastSort(M, T)))
                     /\ transform(M, Cd, s N) 
                fi                
           fi
      fi .
  eq transform(M, T := T' /\ Cd, N) = T' => T /\ transform(M, Cd, N) .
  eq transform(M, T => T' /\ Cd, N) = T => T' /\ transform(M, Cd, N) .
  eq transform(M, T : S /\ Cd, N) = T : S /\ transform(M, Cd, N) .
  eq transform(M, nil, N) = nil .
      
---- ceq transform(M, T = T' /\ Cd, N) 
----    = T' => T /\ transform(M, Cd, N)
----    if vars(T) = none 
----    /\ getTerm(metaNormalize(M, T)) = getTerm(metaReduce(M, T)) . ---- M is assumed terminating to check whether it can be further reduced 
---- ceq transform(M, T = T' /\ Cd, N) 
----    = T => T' /\ transform(M, Cd, N)  
----    if vars(T') = none 
----    /\ getTerm(metaNormalize(M, T')) = getTerm(metaReduce(M, T')) . ---- M is assumed terminating to check whether it can be further reduced  
----  eq transform(M, T = T' /\ Cd, N) 
----    = if | glbSorts(M, leastSort(M, T), leastSort(M, T')) | == 1
----      then T => qid("@X@" + string(N, 10) + ":" + string(glbSorts(M, leastSort(M, T), leastSort(M, T')))) 
----           /\ T' => qid("@X@" + string(N, 10) + ":" + string(glbSorts(M, leastSort(M, T), leastSort(M, T'))))
----           /\ transform(M, Cd, s N) 
----      else T => qid("@X@" + string(N, 10) + ":" + string(leastSort(M, T))) ---- should we use the kind instead of one of them?
----           /\ T' => qid("@X@" + string(N, 10) + ":" + string(leastSort(M, T)))
----           /\ transform(M, Cd, s N) 
----      fi 
----      [owise] . 
    
  op equalOps : KindSet -> OpDeclSet . ---- from MTT-transformations.1.5f.maude
  eq equalOps(K ; KS) = (op 'equal : K K -> 'Thruth [none] .) equalOps(KS) .
  eq equalOps(none) = none .
  
  op equalRls : KindSet -> RuleSet . ---- from MTT-transformations.1.5f.maude
  eq equalRls(K ; KS) 
    = (rl 'equal[qid("X:" + string(K)), qid("X:" + string(K))] => qid("tt.`[Thruth`]") [none] .)
      equalRls(KS) .
  eq equalRls(none) = none .

  op vars2cts : Term -> Tuple{TermList, OpDeclSet} .
  op vars2cts : Term OpDeclSet -> Tuple{TermList, OpDeclSet} .
  op vars2cts : TermList OpDeclSet -> Tuple{TermList, OpDeclSet} .
  eq vars2cts(TL) = vars2cts(TL, none) .
  eq vars2cts(V, ODS) 
    = (qid("##" + string(getName(V)) + "." + string(getType(V))),
       op qid("##" + string(getName(V))) : nil -> getType(V) [none] . ODS) .  
  eq vars2cts(Ct, ODS) = (Ct, ODS) .  
  eq vars2cts(F[TL], ODS) = (F[getTerms(vars2cts(TL))], getOps(vars2cts(TL)) ODS) .  

 ceq vars2cts((T, TL), ODS) 
    = ((getTerms(vars2cts(T)), getTerms(vars2cts(TL))), (getOps(vars2cts(T)) getOps(vars2cts(TL)) ODS)) 
    if TL =/= empty . 
    
  op rulify : Module -> Module .
  op rulify : Module EquationSet -> RuleSet .
  op rulify : Module MembAxSet -> MembAxSet .
  op rulify : Module RuleSet -> RuleSet .
  ---- takes a module an makes all its equations into rules
  
  eq rulify(M) = addRls(rulify(M, getEqs(M)), setRls(setEqs(setMbs(M, rulify(M, getMbs(M))), none), rulify(M, getRls(M)))) .
  
  eq rulify(M, eq T = T' [AtS] . EqS) = (rl T => T' [AtS] .) rulify(M, EqS) . 
  eq rulify(M, ceq T = T' if Cd [AtS] . EqS) = (crl T => T' if transform(M, Cd) [AtS] .) rulify(M, EqS) . 
  eq rulify(M, (none).EquationSet) = none .
  
  eq rulify(M, rl T => T' [AtS] . RlS) = (rl T => T' [AtS] .) rulify(M, RlS) . 
  eq rulify(M, crl T => T' if Cd [AtS] . RlS) = (crl T => T' if transform(M, Cd) [AtS] .) rulify(M, RlS) .
  eq rulify(M, (none).RuleSet) = none .
  
  eq rulify(M, mb T : S [AtS] . MAS) = (mb T : S [AtS] .) rulify(M, MAS) . 
  eq rulify(M, cmb T : S if Cd [AtS] . MAS) = (cmb T : S if transform(M, Cd) [AtS] .) rulify(M, MAS) . 
  eq rulify(M, (none).MembAxSet) = none .
endfm

-------------------------------------------------------------------------------
---- confluence check
-------------------------------------------------------------------------------

**** The \texttt{confluenceCheck} function does the confluence check.

**** The unification function may generate new variables, which will be of 
**** the form X@:S for a variable X:S and X@S':S' for a variable X:S with
**** S' each of the subsorts of S. We assume that these variables are not
**** used in the original module. 

**** Since to check the overlappings there cannot be common variables 
**** between the terms, we generate a renamed copy of one of the
**** equations just by renaming each variable using the \texttt{rename} 
**** function presented in~\ref{basic-stuff}.

view Substitution from TRIV to META-LEVEL is
  sort Elt to Substitution .
endv

fmod CONFLUENCE-CHECK is
  pr CRITICAL-PAIR .
  pr 2TUPLE{CritPairSet, CritPairSet} .
  pr 2TUPLE{Module, QidSet} * (op p1_ to getModule, op p2_ to getCts) .
  pr AUXILIARY-FUNCTIONS .
  inc META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) . 
  pr CRC-CONTEXT-JOINABILITY-UNFEASIBILITY .
  
  vars M M' : Module .
  vars T T' T'' T''' T'''' T1 T1' T2 T2' T1'' T2'' LHS RHS : Term .
  vars CP CP' : CritPair .
  vars CPS CPS' : CritPairSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' EqS'' : EquationSet .
  var  Subst : Substitution .
  var  SubstS : SubstitutionSet .
  vars AtS AtS' : AttrSet .
  var  N : Nat .
  vars X F S L L' L1 L1' L2 L2' : Qid .
  vars TL TL' : TermList .
  vars Cd Cd1 Cd2 Cond : EqCondition .
  vars Sb Sb' : Substitution .
  var  Ct : Constant .
  var  V : Variable . 
  vars Cx Cx' : Context .
  var  Fgs : Flags .
  var  RTS : ResultTripleSet .
  ----var  RCS : ResultContextSet .
  var  TpL : TypeList .
  var  Tp : Type .
  var  NeNL : NeNatList . 
  var  ODS : OpDeclSet .
  var  VS : QidSet .

**** We declare sorts for critical pairs (\texttt{CritPair}) and for sets of
**** critical pairs (\texttt{CritPairSet}), and constructors for them.  The
**** constructors for critical pairs (\texttt{cp}) and for conditional critical
**** pairs (\texttt{ccp}) have, respectively, two and four arguments. The two
**** arguments of \texttt{cp} and the first two of \texttt{ccp} are the terms
**** forming the critical pair. The two last arguments in a conditional critical
**** pair correspond to the condition, which is given following the conventions
**** for conditions in membership axioms, equations, and rules in the
**** \texttt{META-LEVEL} module.

**** Given a specification $\mathcal{S}$, the \texttt{critPairs} function finds
**** all the critical pairs between the equations in $\mathcal{S}$ considered
**** as rules, oriented from left to right. 

**** One critical pair is generated for each unifier for each of the possible
**** nonvariable overlappings of the lefthand sides of any two equations in the
**** module. These critical pairs are calculated by finding all the possible 
**** such pairs for each of the equations in the module (\texttt{critPairs1}) 
**** with a renamed copy of each one of the other equations in the module 
**** (including itself \texttt{critPairs2}). For each pair of equations, their 
**** left sides are unified at any nonvariable position of the term of the 
**** (first equation \texttt{critPairs3}), and then a critical pair is 
**** constructed for each one of the solutions of the unification problem 
**** (\texttt{critPairs4}).

**** As said above, the critical pair is formed by \texttt{critPairs4} for a 
**** pair of equations with an overlapping at some position with some 
**** substitution. In the cases when one or both of the equations involved are
**** conditional, then the conjunction of the conditions with the substitution 
**** applied to them is placed as the condition of the critical pair.

---- nov 7th, 2008
---- The computation of conditional critical pairs is accomplished using Santiago  
---- Escobar's narrowing functionality.
---- Given equations 
----   l(X) = r(X, Y) if C(X, Y)
----   l'(X') = r'(X', Y') if C'(X', Y')
---- we narrow the term 
----   # l(X) # r(X, Y) # C(X, Y) #    
---- (with 2nd and 3rd args. frozen, all other frozen attributes are removed)
---- using the rule
----   l'(X') => # r'(X', Y') # C'(X', Y') #
---- critPairs(M, Eq, Eq) prepares a module with the equation Eq modified as above
---- and uses metaNarrowSearchGenAll to take a narrowing step on a term as the
---- one above obtained from Eq'. 
---- metaNarrowSearchGenAll returns a set of solutions of sort ResultContextSet.
---- A result context is a 10-tuple with information on the narrowing; from 
---- these results we take the resulting term with the substitution applied, 
---- from which we build the critical pair.

  op crcCritPairs : Module -> CritPairSet .
  op crcCritPairs : Module EquationSet EquationSet -> CritPairSet .

  eq crcCritPairs(M) = crcCritPairs(M, getEqs(M), getEqs(M)) .
  
----  eq crcCritPairs(M, Eq EqS, Eq' EqS')
----    ---- Avenhaus & Loria-Saenz discard nonproper critical pairs, i.e., the critical pair of  
----    ---- an equation with itself at the top. Notice that there is always (at least) such an
----    ---- overlapping. They can discard these matches directly because they only consider the  
----    ---- free case. In our case, there might be other matches of one rule with itself at the top.  
----    ---- What we do is that, if there is a single overlap between an equation with itself, we do 
----    ---- not generate the corresponding critical pair. Notice that if there is more than one 
----    ---- we could look the trivial one and discard it, but we don't do this in that case.
----    = if Eq == Eq'
----         and-then
----         | metaNarrowSearchGenAll(
----             getModule(makeNarrowingModule(M, Eq, Eq')), 
----             ---- makeNarrowingModule removes frozen attributes from M, removes eqs 
----             ---- and rls from M, and leaves a prepared version of Eq as single rule
----             '#_#_#_#[lhs(Eq'), rhs(Eq'), makeNarrowingCond(cond(Eq'))],
----             qid("#V:" + string(getKind(M, leastSort(M, lhs(Eq'))))), 
----             none, '+, 1, unbounded, full E-ACU-unify noStrategy) | == 1 
----      then none
----      else prepNarrowingSols(M, getLabel(Eq), getLabel(Eq'), getCts(makeNarrowingModule(M, Eq, Eq')), 
----             metaNarrowSearchGenAll(
----               getModule(makeNarrowingModule(M, Eq, Eq')), 
----               ---- makeNarrowingModule removes frozen attributes from M, removes eqs 
----               ---- and rls from M, and leaves a prepared version of Eq as single rule
----               '#_#_#_#[lhs(Eq'), rhs(Eq'), makeNarrowingCond(cond(Eq'))],
----               qid("#V:" + string(getKind(M, leastSort(M, lhs(Eq'))))), 
----               none, '+, 1, unbounded, full E-ACU-unify noStrategy))  ---- usual parameters
----      fi
----      crcCritPairs(M, Eq, EqS') 
----      crcCritPairs(M, EqS, Eq' EqS') .
  eq crcCritPairs(M, Eq EqS, Eq' EqS')
    = prepNarrowingSols(M, getLabel(Eq), getLabel(Eq'), getCts(makeNarrowingModule(M, Eq, Eq')), 
        metaNarrowSearch(
          getModule(makeNarrowingModule(M, Eq, Eq')), 
          ---- makeNarrowingModule removes frozen attributes from M, removes eqs 
          ---- and rls from M, and leaves a prepared version of Eq as single rule
          '#_#_#_#[lhs(Eq'), rhs(Eq'), makeNarrowingCond(cond(Eq'))],
          qid("#V:" + string(getKind(M, leastSort(M, lhs(Eq'))))), 
          none, '+, 1, unbounded))
      crcCritPairs(M, Eq, EqS') 
      crcCritPairs(M, EqS, Eq' EqS') .
    ---- = prepNarrowingSols(M, getLabel(Eq), getLabel(Eq'), getCts(makeNarrowingModule(M, Eq, Eq')), 
    ----     metaNarrowSearchGenAll(
    ----       getModule(makeNarrowingModule(M, Eq, Eq')), 
    ----       ---- makeNarrowingModule removes frozen attributes from M, removes eqs 
    ----       ---- and rls from M, and leaves a prepared version of Eq as single rule
    ----       '#_#_#_#[lhs(Eq'), rhs(Eq'), makeNarrowingCond(cond(Eq'))],
    ----       qid("#V:" + string(getKind(M, leastSort(M, lhs(Eq'))))), 
    ----       none, '+, 1, unbounded, full E-ACU-unify noStrategy))  ---- usual parameters
    ----   crcCritPairs(M, Eq, EqS') 
    ----   crcCritPairs(M, EqS, Eq' EqS') .
  eq crcCritPairs(M, none, EqS) = none .
  eq crcCritPairs(M, EqS, none) = none .
    
  op makeNarrowingModule : Module Equation Equation -> Tuple{Module, QidSet} . 
  ---- Returns the modified module and the set of variables in the rhs and condition of the 
  ---- 1st eq not in its lhs (it actually returns the set of constants, not variables).
  ---- Constant names are generated just be adding a # in front of the variable's name.
 ceq makeNarrowingModule(M, Eq, Eq')
    = (setRls(
         setEqs(
           addOps(
             (op '#_#_# : leastSort(M, lhs(Eq)) '#EqCondition -> leastSort(M, lhs(Eq)) [none] .
              op '#_#_#_# : leastSort(M, lhs(Eq')) leastSort(M, rhs(Eq')) '#EqCondition -> leastSort(M, lhs(Eq')) [frozen(2 3)] .
              op 'nil : nil -> '#EqCondition [none] .
              op '_/\_ : '#EqCondition '#EqCondition -> '#EqCondition [assoc id('nil.#EqCondition)] .
              opEqCondition(M, cond(Eq) /\ cond(Eq'))
              opNewCts(VS)),
             addSorts('#EqCondition, removeFrozen(M))),
           none),
         rl T' => '#_#_#[vars2narrowCts(T'', VS), vars2narrowCts(T, VS)] [none] .),
       vars2narrowCts(VS)) 
     if T := makeNarrowingCond(cond(Eq))
     /\ T' := getTerm(metaNormalize(M, lhs(Eq)))
     /\ T'' := getTerm(metaNormalize(M, rhs(Eq)))
     /\ VS := (vars(T'') ; vars(T)) \ vars(T') . ---- vars to be made constants

  op vars2narrowCts : Term QidSet -> Term .
  eq vars2narrowCts(V, VS) 
    = if V in VS 
      then qid("#" + string(getName(V)) + "#." + string(getType(V)))
      else V
      fi . 
  eq vars2narrowCts(Ct, VS) = Ct . 
  eq vars2narrowCts(F[TL], VS) = F[vars2narrowCts(TL, VS)] .
  eq vars2narrowCts((T, TL), VS) = (vars2narrowCts(T, VS), vars2narrowCts(TL, VS)) .
  eq vars2narrowCts(empty, VS) = empty .
        
  op vars2narrowCts : QidSet -> QidSet .
  eq vars2narrowCts(V ; VS) = qid("#" + string(getName(V)) + "#." + string(getType(V))) ; vars2narrowCts(VS) .
  eq vars2narrowCts(none) = none .

  op opNewCts : QidSet -> OpDeclSet .
  eq opNewCts(V ; VS) = (op qid("#" + string(getName(V)) + "#") : nil -> getType(V) [none] .) opNewCts(VS) .
  eq opNewCts(none) = none .

  op opEqCondition : Module EqCondition -> OpDeclSet .
  eq opEqCondition(M, T = T' /\ Cond)
    = (op '_=_ : getKind(M, leastSort(M, T)) getKind(M, leastSort(M, T')) -> '#EqCondition [none] .)
      opEqCondition(M, Cond) .
  eq opEqCondition(M, T := T' /\ Cond)
    = (op '_:=_ : getKind(M, leastSort(M, T)) getKind(M, leastSort(M, T')) -> '#EqCondition [none] .)
      opEqCondition(M, Cond) .
  eq opEqCondition(M, T : S /\ Cond)
    = (op '_:_ : getKind(M, leastSort(M, T)) 'Sort -> '#EqCondition [none] .)
      opEqCondition(M, Cond) .
  eq opEqCondition(M, nil) = none .
    
  op prepNarrowingSols : Module Qid Qid QidSet ResultTripleSet -> CritPairSet .
  eq prepNarrowingSols(M, L, L', VS, {'#_#_#_#[T, T', T''], Tp, Sb} | RTS)
    = ccp(L, L', getCPTerm(substitute(M, T, Sb), VS), T', makeCond(T'') /\ makeCond(getCPCond(substitute(M, T, Sb), VS)))
      prepNarrowingSols(M, L, L', VS, RTS) .
  ---- op prepNarrowingSols : Module Qid Qid QidSet ResultContextSet -> CritPairSet .
  ---- eq prepNarrowingSols(M, L, L', VS,
  ----      {
  ----       T, Tp, 
  ----       Sb, Sb', --- computed subs and applied subst
  ----       Cx, Cx', --- Original and WithSubst
  ----       '#_#_#_#[T', T'', T'''], T'''', --- TermWithSubst and ContextWithTermAndSubt
  ----       N, --- highest index of variable
  ----       Fgs
  ----      } | RCS)
  ----   = ccp(L, L', getCPTerm(T', VS), T'', makeCond(T''') /\ makeCond(getCPCond(T', VS)))
  ----     prepNarrowingSols(M, L, L', VS, RCS) .
  eq prepNarrowingSols(M, L, L', VS, empty) = none .
  
  eq ccp(L, L', T, T', nil) = cp(L, L', T, T') .

  op getCPTerm : Term QidSet -> Term .
  op getCPTerm : TermList QidSet -> TermList .
  op getCPCond : Term QidSet -> Term .
  op getCPCond : TermList QidSet -> TermList .
  op restoreVars : TermList QidSet -> TermList .
  
  eq getCPTerm((Ct, TL), VS) = (Ct, getCPTerm(TL, VS)) .
  eq getCPTerm((V, TL), VS) = (V, getCPTerm(TL, VS)) .
  eq getCPTerm(('#_#_#[T, T'], TL), VS) = (restoreVars(T, VS), getCPTerm(TL, VS)) .
  eq getCPTerm((F[TL], TL'), VS) = (F[getCPTerm(TL, VS)], getCPTerm(TL', VS)) [owise] .
  eq getCPTerm(empty, VS) = empty .
  
  eq getCPCond((Ct, TL), VS) = 'nil.#EqCondition .
  eq getCPCond((V, TL), VS) = 'nil.#EqCondition .
  eq getCPCond(('#_#_#[T, T'], TL), VS) = restoreVars(T', VS) .
  eq getCPCond((F[TL], TL'), VS) 
    = if getCPCond(TL, VS) =/= 'nil.#EqCondition then getCPCond(TL, VS) else getCPCond(TL', VS) fi 
    [owise] .
  eq getCPCond(empty, VS) = 'nil.#EqCondition .

  eq restoreVars((Ct, TL), VS) 
    = (if Ct in VS then qid(string(getName(Ct)) + ":" + string(getType(Ct))) else Ct fi, restoreVars(TL, VS)) .
  eq restoreVars((V, TL), VS) = (V, restoreVars(TL, VS)) .
  eq restoreVars((F[TL], TL'), VS) = (F[restoreVars(TL, VS)], restoreVars(TL', VS)) .
  eq restoreVars(empty, VS) = empty .

  op makeNarrowingCond : EqCondition -> Term .
  op makeCond : Term -> EqCondition .
  op makeCondAux : TermList -> EqCondition .
  
  eq makeNarrowingCond(T = T') = '_=_[T, T'] .
  eq makeNarrowingCond(T := T') = '_:=_[T, T'] .
 ceq makeNarrowingCond(T = T' /\ Cond) = '_/\_['_=_[T, T'], makeNarrowingCond(Cond)] if Cond =/= nil .
 ceq makeNarrowingCond(T := T' /\ Cond) = '_/\_['_:=_[T, T'], makeNarrowingCond(Cond)] if Cond =/= nil .
  eq makeNarrowingCond(nil) = 'nil.#EqCondition .
  
  eq makeCond('_/\_[TL]) = makeCondAux(TL) .
  eq makeCond('_=_[T, T']) = T = T' .
  eq makeCond('_:=_[T, T']) = T := T' .
  eq makeCond('nil.#EqCondition) = nil .

  eq makeCondAux(('_/\_[TL], TL')) = makeCondAux((TL, TL')) .
  eq makeCondAux(('_=_[T, T'], TL)) = T = T' /\ makeCondAux(TL) .
  eq makeCondAux(('_:=_[T, T'], TL)) = T := T' /\ makeCondAux(TL) .
  eq makeCondAux(('nil.#EqCondition, TL)) = makeCondAux(TL) .
  eq makeCondAux(empty) = nil .
  
  op getLabel : Equation -> Qid .
  op getLabel : Rule -> Qid .
  eq getLabel(eq LHS = RHS [AtS] .) = getLabel(AtS) .
  eq getLabel(ceq LHS = RHS if Cond [AtS] .) = getLabel(AtS) .
  eq getLabel(rl LHS => RHS [AtS] .) = getLabel(AtS) .
  eq getLabel(crl LHS => RHS if Cond [AtS] .) = getLabel(AtS) .
  
  ---- removes frozen attributes
  op removeFrozen : Module -> Module .
  op removeFrozen : OpDeclSet -> OpDeclSet .
  eq removeFrozen(M) = setOps(M, removeFrozen(getOps(M))) .
  eq removeFrozen(op F : TpL -> Tp [frozen(NeNL) AtS] . ODS) 
    = op F : TpL -> Tp [AtS] . removeFrozen(ODS) .
  eq removeFrozen(ODS) = ODS .
  
  op confluenceCheck : Module -> Tuple{CritPairSet, CritPairSet} .

  eq confluenceCheck(M)
    = (crcCritPairs(M), 
       crcRemoveContextJoinableAndUnfeasibleCPs(M, maximalCPSet(delete(simplify(delete(crcCritPairs(M)), M)), M))) .
endfm

-------------------------------------------------------------------------------
---- descent-check.maude
-------------------------------------------------------------------------------

fmod DESCENT-CHECK is
  pr MATCHING .
  pr SUBSTITUTIONSET . 
  pr EXT-BOOL .
  pr EXT-TERM .
  inc META-LEVEL .

  var  M : Module .
  vars T T' T'' T1 T2 T1' T1'' T2' T2'' : Term .
  var  EqS : EquationSet .
  vars MA MA' : MembAx .
  vars MAS MAS' : MembAxSet .
  vars S S1 S2 : Sort .
  var  Eq : Equation .
  var  X : Qid .
  var  Tp : Type .
  var  TpS : TypeSet .
  var  V : Variable .
  var  VS : QidSet .
  var  Subst : Substitution .
  var  SubstS : SubstitutionSet .
  vars AtS AtS' : AttrSet .
  var  Cd : EqCondition .

  op eqInstanceSet : Module EquationSet -> EquationSet .

  op instanceSet : Module Equation SubstitutionSet -> EquationSet .
  op genSubstSet : Module QidSet Substitution -> SubstitutionSet .
  op genSubstSetAux : Module Qid TypeSet QidSet Substitution -> SubstitutionSet .

  eq eqInstanceSet(M, ((eq T = T' [AtS].) EqS))
    = (instanceSet(M, (eq T = T' [AtS].), genSubstSet(M, vars(T), none))
       eqInstanceSet(M, EqS)) .
  eq eqInstanceSet(M, ((ceq T = T' if Cd [AtS].) EqS))
    = (instanceSet(M, (ceq T = T' if Cd [AtS].), genSubstSet(M, vars(T), none))
       eqInstanceSet(M, EqS)) .
  eq eqInstanceSet(M, none) = none .

  eq instanceSet(M, (eq T = T' [AtS].), (Subst | SubstS))
    = ((eq substitute(M, T, Subst) = substitute(M, T', Subst) [AtS].)
       instanceSet(M, (eq T = T' [AtS].), SubstS)) .
  eq instanceSet(M, (ceq T = T' if Cd [AtS].), 
       (Subst | SubstS))
    = ((ceq substitute(M, T, Subst) = substitute(M, T', Subst)
          if substitute(M, Cd, Subst) [AtS].)
       instanceSet(M, (ceq T = T' if Cd [AtS].), SubstS)) .
  eq instanceSet(M, Eq, empty) = none .

  eq genSubstSet(M, V ; VS, Subst)
    = genSubstSetAux(M, V, getType(V) ; lesserSorts(M, getType(V)), VS, Subst) .
  eq genSubstSet(M, none, Subst) = Subst .

  eq genSubstSetAux(M, V, (Tp ; TpS), VS, Subst)
   = if getType(V) == Tp
     then (genSubstSet(M, VS, Subst) |
           genSubstSetAux(M, V, TpS, VS, Subst))
     else (genSubstSet(M, VS, 
             ((V <- qid(string(getName(V)) + "@" + string(getType(V)) 
                      + ":" + string(getType(V)))) ; Subst)) |
           genSubstSetAux(M, V, TpS, VS, Subst)) 
     fi .     
  eq genSubstSetAux(M, V, none, VS, Subst) = empty .

  op maximalMASet : MembAxSet Module -> MembAxSet .
  op maximalMASetAux : MembAx MembAxSet MembAxSet Module -> MembAxSet .
  op moreGeneralMA? : MembAx MembAx Module -> Bool .

  eq maximalMASet((MA MAS), M) = maximalMASetAux(MA, MAS, none, M) .
  eq maximalMASet(none, M) = none .
  
  eq maximalMASetAux(MA, (MA' MAS), MAS', M)
    = if moreGeneralMA?(MA, MA', M)
      then maximalMASetAux(MA, MAS, MAS', M)
      else if moreGeneralMA?(MA', MA, M)
           then maximalMASetAux(MA', (MAS MAS'), none, M)
           else maximalMASetAux(MA, MAS, (MA' MAS'), M)
           fi
      fi .
  eq maximalMASetAux(MA, none, (MA' MAS), M)
    = (MA maximalMASetAux(MA', MAS, none, M)) .
  eq maximalMASetAux(MA, none, none, M) = MA .

  eq moreGeneralMA?((mb T1 : S1 [AtS].), (mb T2 : S2 [AtS'].), M)
    = metaMatch(M, (eq T1 = T2 [none].)) and-then sortLeq(M, S1, S2) .

  eq moreGeneralMA?((mb T1 : S1 [AtS].),  
                    (cmb T2 : S2 if T2' = T2'' [AtS'].), M)
    = sortLeq(M, S1, S2) and-then metaMatch(M, (eq T1 = T2 [none].)) .
  eq moreGeneralMA?((cmb T1 : S1 if T1' = T1'' [AtS].), 
                    (mb T2 : S2 [AtS'].), M)
    = (T1' == T1'')
      and-then
      (sortLeq(M, S1, S2) and-then metaMatch(M, (eq T1 = T2 [none].))) .

  eq moreGeneralMA?((cmb T1 : S1 if T1' = T1'' [AtS].),
                    (cmb T2 : S2 if T2' = T2'' [AtS'].), M)
    = (T1' == T1'')
      and-then
      (sortLeq(M, S1, S2)
       and-then
       metaMatch(M, ((eq T1 = T2 [none].) (eq T1' = T2 [none].)))) .

  op descentCheck : Module -> MembAxSet .
  op descentCheck1 : Module EquationSet -> MembAxSet .

  eq descentCheck(M)
    = maximalMASet(descentCheck1(M, eqInstanceSet(M, getEqs(M))), M) .

  eq descentCheck1(M, ((eq T = T' [AtS].) EqS))
    = if sortLeq(M, leastSort(M, getTerm(metaReduce(M, T'))), leastSort(M, T))
      then descentCheck1(M, EqS)
      else ((mb T' : (leastSort(M, T)) [(none).AttrSet].)) 
           descentCheck1(M, EqS)
      fi .
  eq descentCheck1(M, none) = none .

  eq descentCheck1(M, ((ceq T = T' if Cd [AtS].) EqS))
    = if sortLeq(M, leastSort(M, getTerm(metaReduce(M, T'))), leastSort(M, T))
      then descentCheck1(M, EqS)
      else ((cmb T' : leastSort(M, T) if Cd [(none).AttrSet].)
            descentCheck1(M, EqS))
      fi .
endfm

-------------------------------------------------------------------------------
---- crc.maude
-------------------------------------------------------------------------------

view Tuple`{CritPairSet`,CritPairSet`} 
    from TRIV to 2TUPLE{CritPairSet, CritPairSet} is
  sort Elt to Tuple{CritPairSet, CritPairSet} .
endv

view MembAxSet from TRIV to META-LEVEL is 
  sort Elt to MembAxSet .
endv

fmod CHURCH-ROSSER-CHECK is
  pr CONFLUENCE-CHECK .
  pr DESCENT-CHECK .
  pr 2TUPLE{Tuple`{CritPairSet`,CritPairSet`}, MembAxSet}
       * (sort Tuple{Tuple`{CritPairSet`,CritPairSet`}, MembAxSet} 
            to CRCCheckingSolution) .
        
  var  M : Module . 

  op CRCheck : Module -> CRCCheckingSolution .

  eq CRCheck(M) = (confluenceCheck(M), descentCheck(M)) .
endfm

-------------------------------------------------------------------------------
---- coherence check
-------------------------------------------------------------------------------

**** CoherenceCheck 
**** local coherence properties reduces to ensuring that the
**** property is verified for all critical pairs\footnote{Note that we only
**** check equational coherence, and thus the non-superposition case is
**** verified.}. 

fmod ChC-CONTEXT-JOINABILITY-UNFEASIBILITY is
  pr CRC-CONTEXT-JOINABILITY-UNFEASIBILITY .
  
  vars QI QI' F : Qid .
  var  VS : QidSet .
  var  V : Variable .
  var  Ct : Constant .
  vars T T' T'' T''' : Term .
  vars TL TL' : TermList .
  var  TS : TermSet .
  vars Cd Cd' : Condition .
  var  N : Nat .
  vars M M' M'' : Module .
  var  Tp : Type .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  CP : CritPair .
  var  CPS : CritPairSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  RlS : RuleSet .
  var  S : Sort .
  var  K : Kind .
  var  KS : KindSet .
  var  DEBUGGING : Bool .
    
  op chcContextJoinable : Module Term Term -> Bool .
  eq chcContextJoinable(M, T, T') 
    = metaSearch(M, T, T', nil, '+, 1, 0) =/= (failure).ResultTriple? .
    
  op chcRemoveContextJoinableAndUnfeasibleCPs : Module CritPairSet -> CritPairSet . 
  eq chcRemoveContextJoinableAndUnfeasibleCPs(M, CP CPS) 
    = if chcRemovable(M, CP)
      then chcRemoveContextJoinableAndUnfeasibleCPs(M, CPS)
      else CP chcRemoveContextJoinableAndUnfeasibleCPs(M, CPS)
      fi .
  eq chcRemoveContextJoinableAndUnfeasibleCPs(M, none) = none .
  
  op chcRemovable : Module CritPair -> Bool .
  op chcRemovable : Module CritPair Bool -> Bool .
  op $chcRemovable : Module CritPair Bool -> Bool .
  
  eq chcRemovable(M, CP) = chcRemovable(M, CP, debugging) .

  eq chcRemovable(M, cp(QI, QI', T, T'), DEBUGGING) = false .  ---- not debugging
  eq chcRemovable(M, ccp(QI, QI', T, T', Cd), DEBUGGING)
    = preunfeasible(M, Cd) 
      or-else 
      $chcRemovable(M, ccp(QI, QI', T, T', Cd), DEBUGGING) .

 ceq $chcRemovable(M, ccp(QI, QI', T, T', Cd), false)
    = chcContextJoinable(M'', getTerms(vars2cts(T)), getTerms(vars2cts(T')))
      or-else
      unfeasible(M, M', M'', Cd')
    if Cd' := transform(M, Cd)            ---- new CCP
    /\ M' := rulify(M)                    ---- turns equations into rules, and equational conditions into rewrites              
    /\ M'' := addRls(                     ---- $\hat{\cR}_{\overline{C}}$
               (getRls(groundRls(Cd'))
                equalRls(getKinds(M))),
               addOps(
                 (op 'tt : nil -> '`[Thruth`] [none] .
                  equalOps(getKinds(M))
                  getOps(groundRls(Cd'))
                  getOps(vars2cts(T))
                  getOps(vars2cts(T'))), 
                 addSorts('Thruth, M'))) .                  
       
  vars CONTEXT-JOINABLE UNFEASIBLE : Bool .
  op $chcRemovableAux : Module CritPair Module Module Condition Bool Bool -> Bool .

  eq $chcRemovable(M, cp(QI, QI', T, T'), true) = false .
 ceq $chcRemovable(M, ccp(QI, QI', T, T', Cd), true)
    = $chcRemovableAux(M, ccp(QI, QI', T, T', Cd), M', M'', Cd', UNFEASIBLE, CONTEXT-JOINABLE)
    if Cd' := transform(M, Cd)            ---- new CCP
    /\ M' := rulify(setRls(M, none))      ---- turns equations into rules, and equational conditions into rewrites              
    /\ M'' := addRls(                     ---- $\hat{\cR}_{\overline{C}}$
               (getRls(groundRls(Cd'))
                equalRls(getKinds(M))),
               addOps(
                 (op 'tt : nil -> '`[Thruth`] [none] .
                  equalOps(getKinds(M))
                  getOps(groundRls(Cd'))
                  getOps(vars2cts(T))
                  getOps(vars2cts(T'))), 
                 addSorts('Thruth, M')))
    /\ UNFEASIBLE := unfeasible(M, M', M'', Cd') 
    /\ CONTEXT-JOINABLE := chcContextJoinable(M'', getTerms(vars2cts(T)), getTerms(vars2cts(T'))) .
 
  eq $chcRemovableAux(M, ccp(QI, QI', T, T', Cd), M', M'', Cd', UNFEASIBLE, CONTEXT-JOINABLE)
    = UNFEASIBLE or CONTEXT-JOINABLE
    ---- [print "cp[" QI "," QI' "]: " T " = " T' " if " Cd] .                  
    [print "cp[" QI "," QI' "]: " T " = " T' " if " Cd " u: " UNFEASIBLE " cj: " CONTEXT-JOINABLE] .                  
endfm

mod COHERENCE-CHECK is
  pr SUBSTITUTIONSET .
  pr EXT-TERM .
  pr AUXILIARY-FUNCTIONS .
  pr CRITICAL-PAIR .
  pr 2TUPLE{EquationSet, OpDeclSet} * (op p1_ to getEqs, op p2_ to getOps) .
  pr 2TUPLE{CritPairSet, CritPairSet} .
  pr UNIT-PROCESSING . 
  pr CONFLUENCE-CHECK .
  pr ChC-CONTEXT-JOINABILITY-UNFEASIBILITY .

  var  M : Module .
  vars T T' T'' T''' T'''' T1 T1' T2 T2' T1'' T2'' LHS RHS : Term .
  vars CP CP' : CritPair .
  vars CPS CPS' : CritPairSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' EqS'' : EquationSet .
  vars Rl : Rule .
  var  RlS : RuleSet .
  var  Subst Sb Sb' : Substitution .
  var  SubstS : SubstitutionSet .
  vars AtS AtS' AtS1 AtS2 : AttrSet .
  var  M' : Module .
  vars X F S L L' L1 L1' L2 L2' QI QI' : Qid .
  var  TL : TermList .
  vars Cd Cd1 Cd2 Cond Cond' : Condition .
  var  TS : TermSet .
  var  N : Nat .
  var  RST? : [ResultTriple] .
  var  VS : QidSet .
  var  Tp : Type .
  vars Cx Cx' : Context .
  var  Fgs : Flags .
  var  RCS : ResultContextSet .
  var  ODS : OpDeclSet .

---- nov 7th, 2008
---- The computation of conditional critical pairs is accomplished using Santiago  
---- Escobar's narrowing functionality.
---- Given an equation 
----   l(X) = r(X, Y) if C(X, Y)
---- and a rule 
----   l'(X') => r'(X', Y') if C'(X', Y')
---- we narrow the term 
----   # l(X) # r(X, Y) # C(X, Y) #    (with 2nd and 3rd args. frozen)
---- using the rule
----   l'(X') -> # r'(X', Y') # C'(X', Y') #
---- and then the term 
----   # l'(X') # r'(X', Y') # C'(X', Y') #    (with 2nd and 3rd args. frozen)
---- using the rule
----   l(X) -> # r(X, Y) # C(X, Y) #
---- (with all other frozen attributes removed).
---- critPairs(M, Eq, Eq) prepares a module with the rule Eq modified as above
---- and uses metaNarrowSearchGenAll to take a narrowing step on a term as the
---- one above obtained from Eq'. 
---- metaNarrowSearchGenAll returns a set of solutions of sort ResultContextSet.
---- A result context is a 10-tuple with information on the narrowing; from 
---- these results we take the resulting term with the substitution applied, 
---- from which we build the critical pair.

  op chcCritPairs : Module -> CritPairSet .
  op chcCritPairs : Module EquationSet RuleSet -> CritPairSet .

  eq chcCritPairs(M) = chcCritPairs(M, getEqs(M), getRls(M)) .
  
  eq chcCritPairs(M, Eq EqS, Rl RlS)
    = prepNarrowingSols(M, getLabel(Eq), getLabel(Rl), getCts(makeNarrowingModule(M, Eq, Rl)), 
        metaNarrowSearch( ---- no ids and no lonely assocs 
          getModule(makeNarrowingModule(M, Eq, Rl)), 
          '#_#_#_#[lhs(Rl), rhs(Rl), makeNarrowingCond(cond(Rl))],
          qid("#V:" + string(getKind(M, leastSort(M, lhs(Rl))))), 
          none, '+, 1, unbounded))
      chcCritPairs(M, Eq, RlS) 
      chcCritPairs(M, EqS, Rl RlS) .
  eq chcCritPairs(M, none, RlS) = none .
  eq chcCritPairs(M, EqS, none) = none .
  
  op makeNarrowingModule : Module Equation Rule -> Tuple{Module, QidSet} . 
  op makeNarrowingModule : Module Rule Equation -> Tuple{Module, QidSet} . 
 ceq makeNarrowingModule(M, Eq, Rl)
    = (setRls(
         setEqs(
           addOps(
             (op '#_#_# : leastSort(M, lhs(Eq)) '#EqCondition -> leastSort(M, lhs(Eq)) [none] .
              op '#_#_#_# : leastSort(M, lhs(Rl)) leastSort(M, rhs(Rl)) '#EqCondition -> leastSort(M, lhs(Rl)) [frozen(2 3)] .
              op 'nil : nil -> '#EqCondition [none] .
              op '_/\_ : '#EqCondition '#EqCondition -> '#EqCondition [assoc id('nil.#EqCondition)] .
              opEqCondition(M, cond(Eq) /\ cond(Rl))
              opNewCts(VS)),
             addSorts('#EqCondition, removeFrozen(M))),
           none),
         rl T => '#_#_#[vars2narrowCts(T', VS), vars2narrowCts(makeNarrowingCond(cond(Eq)), VS)] [none] .),
       vars2narrowCts(VS)) 
     if T := getTerm(metaNormalize(M, lhs(Eq)))
     /\ T' := getTerm(metaNormalize(M, rhs(Eq)))
     /\ VS := (vars(T') ; vars(makeNarrowingCond(cond(Eq)))) \ vars(T) . ---- vars to be made constants
 ceq makeNarrowingModule(M, Rl, Eq)
    = (setRls(
         setEqs(
           addOps(
             (op '#_#_# : leastSort(M, lhs(Rl)) '#EqCondition -> leastSort(M, lhs(Rl)) [none] .
              op '#_#_#_# : leastSort(M, lhs(Eq)) leastSort(M, rhs(Eq)) '#EqCondition -> leastSort(M, lhs(Eq)) [frozen(2 3)] .
              op 'nil : nil -> '#EqCondition [none] .
              op '_/\_ : '#EqCondition '#EqCondition -> '#EqCondition [assoc id('nil.#EqCondition)] .
              opEqCondition(M, cond(Rl) /\ cond(Eq))
              opNewCts(VS)),
             addSorts('#EqCondition, M)), -------- we do not remove the frozenness information in this case
           none),
         rl T => '#_#_#[vars2narrowCts(T', VS), vars2narrowCts(makeNarrowingCond(cond(Rl)), VS)] [none] .),
       vars2narrowCts(VS)) 
     if T := getTerm(metaNormalize(M, lhs(Rl)))
     /\ T' := getTerm(metaNormalize(M, rhs(Rl)))
     /\ VS := (vars(T') ; vars(makeNarrowingCond(cond(Rl)))) \ vars(T) . ---- vars to be made constants

  op prepNarrowingSols : Module Equation Rule QidSet ResultContextSet -> CritPairSet .
  op prepNarrowingSols : Module Rule Equation QidSet ResultContextSet -> CritPairSet .
  eq prepNarrowingSols(M, Eq, Rl, VS,
       {
        T, Tp, 
        Sb, Sb', --- computed subs and applied subst
        Cx, Cx', --- Original and WithSubst
        '#_#_#_#[T', T'', T'''], T'''', --- TermWithSubst and ContextWithTermAndSubt
        N, --- highest index of variable
        Fgs
       } | RCS)
    = ccp(getLabel(Eq), getLabel(Rl), getCPTerm(T', VS), T'', makeCond(T''') /\ makeCond(getCPCond(T', VS)))
      prepNarrowingSols(M, Eq, Rl, VS, RCS) .
  eq prepNarrowingSols(M, Rl, Eq, VS,
       {
        T, Tp, 
        Sb, Sb', --- computed subs and applied subst
        Cx, Cx', --- Original and WithSubst
        '#_#_#_#[T', T'', T'''], T'''', --- TermWithSubst and ContextWithTermAndSubt
        N, --- highest index of variable
        Fgs
       } | RCS)
    = ccp(getLabel(Eq), getLabel(Rl), T'', getCPTerm(T', VS), makeCond(T''') /\ makeCond(getCPCond(T', VS)))
      prepNarrowingSols(M, Rl, Eq, VS, RCS) .
  eq prepNarrowingSols(M, Rl, Eq, VS, empty) = none .
  
  op rewriteCPs : Module CritPairSet -> CritPairSet .
  eq rewriteCPs(M, CP CPS)
----    = if metaSearch(M, lhs(CP), getTerm(metaReduce(M, rhs(CP))), nil, '+, 1, 0) == (failure).ResultTriple?
    = if metaSearch(M, lhs(CP), rhs(CP), nil, '+, 1, 0) == (failure).ResultTriple?
      then CP rewriteCPs(M, CPS)
      else rewriteCPs(M, CPS)
      fi .
  eq rewriteCPs(M, none) = none .

  op chcSimplify : CritPairSet Module -> CritPairSet .
  eq chcSimplify(cp(L, L', T, T') CPS, M)
    = cp(L, L', getTerm(metaReduce(M, T)), getTerm(metaReduce(M, T')))
      chcSimplify(CPS, M) .
  eq chcSimplify(ccp(L, L', T, T', Cd) CPS, M)
    = ccp(L, L', getTerm(metaReduce(M, T)), getTerm(metaReduce(M, T')), simplifyCond(M, Cd))
      chcSimplify(CPS, M) .
  eq chcSimplify(none, M) = none .

  op simplifyCond : Module Condition -> Condition .
  eq simplifyCond(M, T = T' /\ Cd) 
    = if getTerm(metaReduce(M, T)) == getTerm(metaReduce(M, T'))
      then simplifyCond(M, Cd)
      else if getTerm(metaReduce(M, T)) == 'true.Bool
           then getTerm(metaReduce(M, T')) = getTerm(metaReduce(M, T)) /\ simplifyCond(M, Cd)
           else getTerm(metaReduce(M, T)) = getTerm(metaReduce(M, T')) /\ simplifyCond(M, Cd)
           fi 
      fi . 
  eq simplifyCond(M, T := T' /\ Cd) 
    = getTerm(metaReduce(M, T)) := getTerm(metaReduce(M, T')) /\ simplifyCond(M, Cd) . 
  eq simplifyCond(M, Cd) = Cd [owise] . 

  op groundEqs : Module Condition -> Tuple{EquationSet, OpDeclSet} .
  op groundEqs : Module Condition EquationSet OpDeclSet -> Tuple{EquationSet, OpDeclSet} .
  eq groundEqs(M, Cd) = groundEqs(M, Cd, none, none) .
  eq groundEqs(M, T => T' /\ Cd, EqS, ODS) 
    = groundEqs(M, Cd, eq getTerms(vars2cts(getTerm(metaReduce(M, T)))) 
                         = getTerms(vars2cts(getTerm(metaReduce(M, T')))) [none] . EqS, 
        getOps(vars2cts(getTerm(metaReduce(M, T)))) 
        getOps(vars2cts(getTerm(metaReduce(M, T')))) ODS) .
  ---- I'm assuming the = and := conditions have been converted into =>
  eq groundEqs(M, Cd, EqS, ODS) = (EqS, ODS) [owise] .
  
  op chcCheck : Module -> Tuple{CritPairSet, CritPairSet} .

  eq chcCheck(M)
    = (chcCritPairs(M),
       chcRemoveContextJoinableAndUnfeasibleCPs(M, 
         maximalCPSet(
           rewriteCPs(M, 
             delete(
               chcSimplify(
                 chcCritPairs(M), 
                 M))), 
           M))) .
endm

-------------------
------SIGN
-------------------

fmod CRC-SIGN is
  including FULL-MAUDE-SIGN .

  op check`Church-Rosser`. : -> @Command@ .
  op check Church-Rosser_. : @ModExp@ -> @Command@ .
  op crc`. : -> @Command@ .
  op crc_. : @ModExp@ -> @Command@ .
  op show CRC critical pairs . : -> @Command@ .
  op show all CRC critical pairs . : -> @Command@ .
endfm


fmod CHC-SIGN is
  including FULL-MAUDE-SIGN .

  op check coherence . : -> @Command@ .
  op check coherence_. : @ModExp@ -> @Command@ .
  op check ground coherence . : -> @Command@ .
  op check ground coherence_. : @ModExp@ -> @Command@ .
  op chc . : -> @Command@ .
  op chc_. : @ModExp@ -> @Command@ .
  op show ChC critical pairs . : -> @Command@ .
  op show all ChC critical pairs . : -> @Command@ .
endfm


fmod META-CRCHC-SIGN is
  inc META-LEVEL .
  pr META-FULL-MAUDE-SIGN .
  pr UNIT .

  op CRCHC-GRAMMAR : -> FModule .
  eq CRCHC-GRAMMAR 
    = addImports((including 'CRC-SIGN . including 'CHC-SIGN .), GRAMMAR) .
endfm

fmod CHC-NON-OVERLAPPING-CHECK is
  pr EXT-SORT .
  pr EXT-DECL .
  pr DESCENT-CHECK .
  
  var  M : Module .
  var  F : Qid .
  vars S S' : Sort .
  var  SS : SortSet .
  var  TyL : TypeList .
  var  TyS : TypeSet .
  var  SSDS : SubsortDeclSet .
  var  ODS : OpDeclSet .
  var  AtS : AttrSet .
  var  T : Term .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  vars VS VS' : QidSet .
  vars VL VL' VL'' : QidList .
  vars V V' : Variable .
  var  C : Constant .
  var  Ty : Type .
  var  TL : TermList .
  var  Subst : Substitution .
  var  SubstS : SubstitutionSet .   
  var  NL : NatList .
  var  N : Nat .

  op closure : Sort Module -> TypeSet .
  op closureAux : TypeSet SubsortDeclSet OpDeclSet -> TypeSet .

  eq closure(S, M) = closureAux(S, getSubsorts(M), getOps(M)) .
  eq closureAux(S ; TyS, subsort S' < S . SSDS, ODS)
    =  closureAux(S ; S' ; TyS, SSDS, ODS) .
  eq closureAux(S ; TyS, SSDS, op F : TyL -> S [AtS] . ODS)
    =  closureAux(S ; list2set(TyL) ; TyS, SSDS, ODS) .
  eq closureAux(TyS, SSDS, ODS) = TyS [owise] .

  op specializations : Module Term -> TermSet .
  op specializations : Module Term SubstitutionSet -> TermSet .

  eq specializations(M, T) = specializations(M, T, genSubstSet(M, vars(T), none)) .

  eq specializations(M, T, (Subst | SubstS)) 
    = substitute(M, T, Subst) | specializations(M, T, SubstS) .
  eq specializations(M, T, empty) = emptyTermSet .
  
  sort NonOverlappingCheckSolution .
  op ok : -> NonOverlappingCheckSolution [ctor] .
  op ((_,_,_)) : Equation Variable Rule -> NonOverlappingCheckSolution [ctor] .
  
  op nonOverlappingCheck : Module -> NonOverlappingCheckSolution .
  op nonOverlappingCheck : Module EquationSet RuleSet -> NonOverlappingCheckSolution .
  op nonOverlappingCheck : Module Equation QidSet RuleSet -> NonOverlappingCheckSolution .
  op nonOverlappingCheckAux : Module Equation Variable RuleSet -> NonOverlappingCheckSolution .
  op nonOverlappingCheck : Module Equation Variable Rule QidSet -> NonOverlappingCheckSolution .
   
 ceq nonOverlappingCheck(M) 
    = nonOverlappingCheck(M, getEqs(M), getRls(M)) 
    if getEqs(M) =/= none or getRls(M) =/= none .
  eq nonOverlappingCheck(M) = ok [owise] .
  
 ceq nonOverlappingCheck(M, Eq EqS, RlS) 
    = if (VS' == none) or-else (nonOverlappingCheck(M, Eq, VS', RlS) == ok)
      then nonOverlappingCheck(M, EqS, RlS)
      else nonOverlappingCheck(M, Eq, VS', RlS)
      fi 
    if VS := (nonLinear(lhs(Eq)) ; nonLinear(rhs(Eq))) 
    /\ VS' := (nonFrozen(M, getOps(M), lhs(Eq), VS) ; nonFrozen(M, getOps(M), rhs(Eq), VS)) .
  eq nonOverlappingCheck(M, none, RlS) = ok .
  
  eq nonOverlappingCheck(M, Eq, (V ; VS), RlS)
    = if nonOverlappingCheckAux(M, Eq, V, RlS) == ok 
      then nonOverlappingCheck(M, Eq, VS, RlS)
      else nonOverlappingCheckAux(M, Eq, V, RlS)
      fi .
  eq nonOverlappingCheck(M, Eq, none, RlS) = ok .
      
  eq nonOverlappingCheckAux(M, Eq, V, Rl RlS)
    = if nonOverlappingCheck(M, Eq, V, Rl, list2set(eLeastSort(M, specializations(M, lhs(Rl))))) == ok 
      then nonOverlappingCheckAux(M, Eq, V, RlS)
      else nonOverlappingCheck(M, Eq, V, Rl, list2set(eLeastSort(M, specializations(M, lhs(Rl)))))
      fi .
  eq nonOverlappingCheckAux(M, Eq, VS, none) = ok .
      
  eq nonOverlappingCheck(M, Eq, V, Rl, SS)
    = if sortLeqSome(M, SS, getType(V)) 
      then (Eq, V, Rl) ---- counterexample
      else ok 
      fi .

  op sortLeqSome : Module SortSet Sort -> Bool .
  eq sortLeqSome(M, S ; SS, S') = sortLeq(M, S, S') or-else sortLeqSome(M, SS, S) .
  eq sortLeqSome(M, none, S) = false .

  op nonLinear : Term -> QidSet .
  op nonLinearAux : QidList -> QidSet .
  op varList : TermList -> QidList .
  eq nonLinear(T) = nonLinearAux(varList(T)) .
  eq nonLinearAux(VL V VL' V VL'') = V ; nonLinearAux(VL VL' VL'') .
  eq nonLinearAux(VL) = none [owise] . 
  eq varList(V) = V .
  eq varList(C) = nil .
  eq varList(F[TL]) = varList(TL) .
  eq varList((T, TL)) = varList(T) varList(TL) .
  eq varList(empty) = nil .

  op nonFrozen : Module OpDeclSet Term QidSet -> QidSet .
  op frozen : Module OpDeclSet Term -> QidSet .
  op vars : NatList TermList -> QidSet .
  op get : NzNat TermList -> QidSet .
  eq nonFrozen(M, ODS, T, VS)
    = VS \ frozen(M, ODS, T) .
 ceq frozen(M, op F : TyL -> Ty [frozen(NL) AtS] . ODS, F[TL])
    = vars(NL, TL)
    if sameKind(M, TyL Ty, eLeastSort(M, TL) leastSort(M, F[TL])) .
  eq frozen(M, ODS, F[TL]) = frozen(M, ODS, TL) [owise] .
 ceq frozen(M, ODS, (T, TL)) = frozen(M, ODS, T) ; frozen(M, ODS, TL) if TL =/= empty .
  eq frozen(M, ODS, empty) = none .
  eq frozen(M, ODS, V) = none .
  eq frozen(M, ODS, C) = none .
  eq vars(N NL, TL) = vars(get(N, TL)) ; vars(NL, TL) .
  eq vars(nil, TL) = none . 
  eq get(s 0, (T, TL)) = T .
  eq get(s s N, (T, TL)) = get(s N, TL) .
  
  op lhs : RuleSet -> TermSet .
 ceq lhs(Rl RlS) = lhs(Rl) | lhs(RlS) if RlS =/= none .
  eq lhs((none).RuleSet) = emptyTermSet .
endfm

mod CRCHC-DATABASE-HANDLING is
  pr DATABASE-HANDLING . ---- * (op termSet to _&_, op emptyTermSet to emptyTS) .
  pr CHURCH-ROSSER-CHECK .
  pr COHERENCE-CHECK .
  pr CHC-NON-OVERLAPPING-CHECK .
  pr (LIST-AND-SET{Qid}) 
       * (sort NeList{Qid} to NeQidList, sort List{Qid} to QidList,
          sort NeSet{Qid} to NeQidSet, sort Set{Qid} to QidSet)
       * (op empty to none, 
          op _,_ to _;_ [prec 43]) .
  pr 3TUPLE{ModuleName, CritPairSet, CritPairSet} .
  pr 4TUPLE{ModuleName, CritPairSet, CritPairSet, QidList} .
  pr 2TUPLE{Nat, TermSet} .
  pr (2TUPLE * (op `(_`,_`) to `[_`,_`])){Nat, TermList} .
  pr CRC-HELP .
  pr CHC-HELP .

  var  VS : QidSet .
  var  S : Sort .
  vars ME ME' MN MN' MN'' MN''' : ModuleExpression .
  vars DB DB' : Database .
  vars M M' M'' : Module .
  var  CP : CritPair .
  vars CPS CPS' CPS'' CPS''' : CritPairSet .
  var  MA : MembAx .
  var  MAS : MembAxSet .
  vars QIL QIL' : QidList .
  var  Atts : AttributeSet .
  var  X@CRChC : CRChC .
  var  O : Oid .
  vars T T' T'' T''' : Term .  
  var  V : Variable .
  var  TS : TermSet .
  var  TL : TermList .
  var  ODS : OpDeclSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Ct : Constant .
  vars QI QI' F L L' : Qid .
  var  Vb : Variable .
  vars Tp Tp' : Type .
  var  TpL : TypeList .
  var  AtS : AttrSet .
  var  N : Nat .
  vars Cd Cd' : Condition .
  var  VT : [Tuple{ModuleName, CritPairSet, CritPairSet, QidList}] .
  var  NL : NatList .
  var  GROUND : Bool .
 
  op CRChC : -> CRChC .
  op crc :_ : Tuple{ModuleName, CritPairSet, CritPairSet} -> Attribute .
  op chc :_ : Tuple{ModuleName, CritPairSet, CritPairSet} -> Attribute .

  sort CRChC .
  subsort CRChC < DatabaseClass .

**** The processing of the checking commands is handled by the following function
**** \texttt{processChCCheck}. Given a module
**** expression and a database, it just calls the \texttt{checking} function
**** presented in Section~\ref{CohCh-specification} with the flat form of the
**** specified module in the database, and then gives the output as a list of
**** quoted identifiers ready to be passed to the read-eval-print loop.

  sort ChCProcessResult .
  subsorts QidList Tuple{ModuleName, CritPairSet, CritPairSet, QidList} < ChCProcessResult .
  
  op processCRCheck : ModuleExpression Database -> Tuple{ModuleName, CritPairSet, CritPairSet, QidList} .
  op $processCRCheckAux : Module CRCCheckingSolution -> Tuple{ModuleName, CritPairSet, CritPairSet, QidList} .
  op processChCCheck : ModuleExpression Bool Database -> ChCProcessResult . --- the Bool indicates whether it is ground or not
  op $processChCCheckAux : Module Bool Database -> ChCProcessResult .
  op $processChCCheckAux : Module Bool Tuple{CritPairSet, CritPairSet} -> ChCProcessResult .
  op $processChCCheckAux : Module Bool NonOverlappingCheckSolution -> ChCProcessResult .

 ceq processChCCheck(ME, GROUND, DB)
    = $processChCCheckAux(M, GROUND, DB)
    if < DB' ; ME' > := evalModExp(ME, DB) 
    /\ M := getFlatModule(ME', DB') .
 ceq processChCCheck(ME, GROUND, DB)
    = ('no-name.Qid, (none).CritPairSet, (none).CritPairSet, QIL)
    if < DB' ; ME' > := evalModExp(ME, DB) 
    /\ unitError(QIL) := getFlatModule(ME', DB') .

 ceq $processChCCheckAux(M, GROUND, DB)
    = if coveredCase(M) == nil
      then if nonOverlappingCheck(M') == ok
           then $processChCCheckAux(M, GROUND, chcCheck(M'))
           else $processChCCheckAux(M, GROUND, nonOverlappingCheck(M'))
           fi 
      else ('no-name.Qid, (none).CritPairSet, (none).CritPairSet, coveredCase(M))
      fi 
    if M' := removeLonelyAssocs(removeIds(acuCohComplete(removeNonExecs(M)))) .

 ceq processCRCheck(ME, DB)
    = if coveredCase(M) == nil
      ----then processCRCheckAux(M, CRCheck(M))
      then $processCRCheckAux(M, CRCheck(removeLonelyAssocs(removeIds(acuCohComplete(removeNonExecs(M)))))) 
      else ('no-name.Qid, (none).CritPairSet, (none).CritPairSet, coveredCase(M))
      fi
    if < DB' ; ME' > := evalModExp(ME, DB) 
    /\ M := getFlatModule(ME', DB') .
 ceq processCRCheck(ME, DB)
    = ('no-name.Qid, (none).CritPairSet, (none).CritPairSet, QIL)
    if < DB' ; ME' > := evalModExp(ME, DB) 
    /\ unitError(QIL) := getFlatModule(ME', DB') .
    
  eq $processCRCheckAux(M, ((CPS, CPS'), MAS))
    ---- CPS is the set of critical pairs critPairs(M)
    ---- CPS' is the set of unjoined critical pairs maximalCPSet(delete(simplify(delete(critPairs(M), M)), M))
    ---- MAS is the set of mbs returned by descentCheck(M) 
    = (getName(M), CPS, CPS', 
       '\n '\b 'Church-Rosser 'checking 'of '\o eMetaPrettyPrint(getName(M)) '\n 
       '\b 'Checking 'solution: '\o
       if CPS == none 
       then '\b '\n 
            'There 'are 'no 'critical 'pairs.
            '\b '\n 
            'The 'specification 'is 'confluent. '\o
       else if CPS' == none 
            then '\b '\n 
                 'All 'critical 'pairs 'have 'been 'joined. 
                 '\n 
                 'The 'specification 'is 'locally-confluent. '\o
            else '\b '\n 
                 'The 'following 'critical 'pairs 'cannot 'be 'joined: '\o
                 eMetaPrettyPrint(M, '=, CPS') 
            fi
       fi
       if MAS == none
       then '\b '\n 
            'The 'specification 'is 'sort-decreasing. '\o
       else '\b '\n 
            'There 'are 'non-sort-decreasing 'equations. 
            '\n 
            'The 'following 'proof 'obligations 'must 'be 'checked:
            eMetaPrettyPrint(M, MAS)
       fi 
       '\n) .
----  eq processCRCheckAux(unitError(QIL), V:[CRCCheckingSolution]) = (none, none, QIL) .

  eq $processChCCheckAux(M, GROUND, (Eq, V, Rl))
    = 'Rule 
      if label(Rl) :: Qid then label(Rl) else eMetaPrettyPrint(M, Rl) '\n fi  
      'can 'be 'applied 'under 'the 'non-frozen 'and 'non-linear 'variable 
      V 
      'of 'equation 
      if label(Eq) :: Qid then label(Eq) else eMetaPrettyPrint(M, Eq) '\n fi .
  eq $processChCCheckAux(M, GROUND, (CPS, CPS'))
    = (getName(M), CPS, CPS', 
       ('\n '\b 'Coherence 'checking 'of '\o eMetaPrettyPrint(getName(M)) 
        '\n '\b 'Coherence 'checking 'solution: 
        if CPS' == none
        then if ctorEqs(M) == none
             then '\n 'All 'critical 'pairs 'have 'been 'rewritten 'and 'all 
                  'equations 'are 'non-constructor.
                  if CPS == none
                  then '\n 'The 'specification 'is 'coherent. '\o
                  else '\n 'The 'specification 'is 'ground 'coherent. '\o
                  fi
             else if chReq(ctorEqs(M)) == none
                  then '\n 'All 'critical 'pairs 'have 'been 'rewritten 'and 'all 
                       'equations 'with 'a 'constructor 'symbol 'at 'the 'top 'of 
                       'their 'lefthand 'side 'are 'left- 'and 'right-linear 'and 
                       'regular.
                       if CPS == none
                       then 'The 'specification 'is 'coherent. '\o
                       else 'The 'specification 'is 'ground 'coherent. '\o
                       fi
                  else '\n 'All 'critical 'pairs 'have 'been 'rewritten. 'However`, 'the 
                       'specification 'might 'fail 'to 'be 'ground 'coherent 'if 
                       'there 'exist 'non-overlap 'situations 'rewriting 'at 'the 
                       'top 'with 'the 'equations: '\o
                       eMetaPrettyPrint(M, chReq(ctorEqs(M)))
                       '\n '\b 'and 'below 'with 'rules 'in 'the 'module 'can 'take 'place. 
                  fi
             fi
        else '\n 'The 'following 'critical 'pairs 'cannot 'be 'rewritten: '\o
             if not GROUND 
             then eMetaPrettyPrint(M, '=>, CPS')
             else eMetaPrettyPrintGroundChC(M, CPS')
             fi 
        fi 
        '\n)) .

  op vars : CritPair -> QidSet .
  eq vars(cp(L, L', T, T')) = vars(T) ; vars(T') .
  eq vars(ccp(L, L', T, T', Cd)) = vars(T) ; vars(T') .
  
  op forall : QidSet -> QidList .
  op forallAux : QidSet -> QidList .
  eq forall(none) = nil .
  eq forall(VS) = 'A '`( forallAux(VS) '`) [owise] .
  eq forallAux(V) = V .
  eq forallAux(none) = nil .
  eq forallAux(V ; VS) = V '; forallAux(VS) [owise] .

  op eMetaPrettyPrintGroundChC : Module CritPairSet -> QidList .
  op $chcpos : Module CritPair -> QidList .
  ops $chcpos $chcposAux : Module RuleSet Term Term -> QidList .
  op $chcpos : Module Condition Term Term Nat -> QidList .
  
  eq eMetaPrettyPrintGroundChC(M, cp(L, L', T, T') CPS)
    = eMetaPrettyPrint(M, '=>, cp(L, L', T, T'))
      '\n '\s '\s '\b 'Inductive 'ground 'joinability 'amounts 'to 'proving 'the 'following 'inductive 'theorem: '\o 
      ---- if $chcpos(M, cp(L, L', T, T')) =/= nil
      ---- then 
           '\n '\s '\s '\b 'E 'U 'A '|-ind '\o forall(vars(cp(L, L', T, T'))) '\n 
                '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s $chcpos(M, cp(L, L', T, T'))
      ---- else nil
      ---- fi  
      eMetaPrettyPrintGroundChC(M, CPS) .
  eq eMetaPrettyPrintGroundChC(M, ccp(L, L', T, T', Cd) CPS)
    = eMetaPrettyPrint(M, '=>, ccp(L, L', T, T', Cd))
      '\n '\s '\s '\b 'Inductive 'ground 'joinability 'amounts 'to 'proving 'the 'following 'inductive 'theorem: '\o
      ---- if $chcpos(M, ccp(L, L', T, T', Cd)) =/= nil
      ---- then 
           '\n '\s '\s '\b 'E 'U 'A '|-ind '\o forall(vars(ccp(L, L', T, T', Cd))) '\n 
           if Cd == nil 
           then nil
           else '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s eMetaPrettyPrint(M, Cd) '\n 
           fi
           '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\b '=> '\o 
           $chcpos(M, ccp(L, L', T, T', Cd))
      ---- else nil
      ---- fi  
      eMetaPrettyPrintGroundChC(M, CPS) .
  eq eMetaPrettyPrintGroundChC(M, none) = nil .
  
  eq $chcpos(M, cp(L, L', T, T')) 
    = $chcpos(M, getRls(M), T, T') . 
 ceq $chcpos(M, ccp(L, L', T, T', Cd)) 
    = $chcpos(M', getRls(M'), T, T')
    if Cd' := transform(M, Cd)
    /\ M' := addEqs(            
               getEqs(groundEqs(M, Cd')),
               addOps(
                 getOps(groundEqs(M, Cd')), 
                 M)) .                  

  eq $chcpos(M, rl T => T' [AtS] . RlS, T'', T''') 
    ---- M is the module \overline{C}
    ---- T'' is the 'groundified' lhs of the critical pair
    ---- T''' is the rhs of the cp
    = $chcpos(setRls(M, rl T => T' [label('theRule)] .), nil, T'', T''', 0) --- 'theRule is the only rule in the module 
      if $chcpos(setRls(M, rl T => T' [label('theRule)] .), nil, T'', T''', 0) == nil
      then $chcpos(M, RlS, T'', T''')
      else $chcposAux(M, RlS, T'', T''')
      fi .
  eq $chcpos(M, crl T => T' if Cd [AtS] . RlS, T'', T''') 
    = $chcpos(setRls(M, rl T => T' [label('theRule)] .), Cd, T'', T''', 0) --- 'theRule is the only rule in the module 
      if $chcpos(setRls(M, rl T => T' [label('theRule)] .), Cd, T'', T''', 0) == nil 
      then $chcpos(M, RlS, T'', T''')
      else $chcposAux(M, RlS, T'', T''') 
      fi  
       .
  eq $chcpos(M, none, T, T') = nil . 
  
  eq $chcposAux(M, rl T => T' [AtS] . RlS, T'', T''') 
    ---- M is the module \overline{C}
    ---- T'' is the 'groundified' lhs of the critical pair
    ---- T''' is the rhs of the cp
    = if $chcpos(setRls(M, rl T => T' [label('theRule)] .), nil, T'', T''', 0) =/= nil
      then '\n '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s 
           '\b '\/ '\o $chcpos(setRls(M, rl T => T' [label('theRule)] .), nil, T'', T''', 0)
      else nil
      fi 
      $chcposAux(M, RlS, T'', T''') .
  eq $chcposAux(M, crl T => T' if Cd [AtS] . RlS, T'', T''') 
    = if $chcpos(setRls(M, rl T => T' [label('theRule)] .), Cd, T'', T''', 0) =/= nil 
      then '\n '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s 
           '\b '\/ '\o $chcpos(setRls(M, rl T => T' [label('theRule)] .), Cd, T'', T''', 0)
      else nil 
      fi  
      $chcposAux(M, RlS, T'', T''') .
  eq $chcposAux(M, none, T, T') = nil . 
  
  eq $chcpos(M, Cd, T, T', N) 
    ---- M is the module \overline{C} with 'theRule as only rule
    ---- Cd is the condition of the rule
    ---- T is the 'groundified' lhs of the critical pair
    ---- T' is the rhs of the cp
    ---- N is the matching 
    = if metaApply(M, T, 'theRule, none, N) == (failure).ResultTriple?
      then nil
      else if Cd == nil
           then nil
           else eMetaPrettyPrint(M, applySubst(Cd, getSubstitution(metaApply(M, T, 'theRule, none, N))))
                '\n '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s '\s 
                '\b '/\ '\o 
           fi
           eMetaPrettyPrint(M, getTerm(metaApply(M, T, 'theRule, none, N)))
               '\b '= '\o
               eMetaPrettyPrint(M, applySubst(T', getSubstitution(metaApply(M, T, 'theRule, none, N))))
           $chcpos(M, Cd, T, T', s N)
      fi . 
  
  op freezeNonCtors : Module -> Module .
  op $freezeNonCtors : OpDeclSet -> OpDeclSet .
  op $frozenPositions : NeTypeList -> NeNatList .
  op $frozenPositions : TypeList Nat -> NatList .
  
  eq freezeNonCtors(M) = setOps(M, $freezeNonCtors(getOps(M))) .
  eq $freezeNonCtors(op F : TpL -> Tp [ctor AtS] . ODS)
    = op F : TpL -> Tp [ctor AtS] . $freezeNonCtors(ODS) .
  eq $freezeNonCtors(op F : TpL -> Tp [frozen(NL) AtS] . ODS)
    = op F : TpL -> Tp [frozen(NL) AtS] . $freezeNonCtors(ODS) .
  eq $freezeNonCtors(op F : nil -> Tp [AtS] . ODS)
    = op F : nil -> Tp [AtS] . $freezeNonCtors(ODS) .
  eq $freezeNonCtors(op F : TpL -> Tp [AtS] . ODS)
    = op F : TpL -> Tp [frozen($frozenPositions(TpL)) AtS] . $freezeNonCtors(ODS) [owise] .
  eq $freezeNonCtors(none) = none .

  eq $frozenPositions(TpL) = $frozenPositions(TpL, 1) . 
  eq $frozenPositions(Tp TpL, N) = N $frozenPositions(TpL, s N) .
  eq $frozenPositions(nil, N) = nil .

  op coveredCase : Module -> QidList .
  ---- nil if applicable; an error message otherwise
  eq coveredCase(M)
    = if specialAttr(getOps(M))
      then ('\n 'The 'use 'of 'built-ins 'is 'not 'supported 'by 'the 'checker. '\n)  
      else if attr(getOps(M), owise)
           then ('\n 'The 'use 'of 'the 'owise 'attribute 'is 'not 'supported 'by 'the 'checker. '\n)  
           else if attr(getOps(M), idem)
                then ('\n 'The 'use 'of 'the 'idem 'attribute 'is 'not 'supported 'by 'the 'checker. '\n)  
                else if attr(getOps(M), iter)
                     then ('\n 'The 'use 'of 'the 'iter 'attribute 'is 'not 'supported 'by 'the 'checker. '\n)
                     else if singleVbleInLHSs(getRls(M))
                          then ('\n 'The 'module 'has 'rules 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
                          else if singleVbleInLHSs(getEqs(M))
                               then ('\n 'The 'module 'has 'equations 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
                               else if not order-sorted(M)
                                    then ('\n 'The 'checker 'only 'covers 'the 'order-sorted 'case. '\n)
                                    else nil
                                    fi
                               fi
                          fi
                     fi
                fi
           fi
      fi .
  
  op order-sorted : Module -> Bool .
  op order-sorted : EquationSet -> Bool .
  op order-sorted : RuleSet -> Bool .
  op order-sorted : Condition -> Bool .
  eq order-sorted(M) 
    = getMbs(M) == none and-then order-sorted(getEqs(M)) and-then order-sorted(getRls(M)) .
  eq order-sorted(Eq EqS) = order-sorted(cond(Eq)) and-then order-sorted(EqS) .
  eq order-sorted((none).EquationSet) = true .
  eq order-sorted(Rl RlS) = order-sorted(cond(Rl)) and-then order-sorted(RlS) .
  eq order-sorted((none).RuleSet) = true .
  eq order-sorted(T : S /\ Cd) = false .
  eq order-sorted(Cd) = true [owise] .
  
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser`..@Command@), 
        output : QIL, default : MN, crc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL QIL'), default : MN, crc : (MN'', CPS'', CPS'''), Atts > 
     if (MN'', CPS'', CPS''', QIL') := processCRCheck(MN, DB) .
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser_.[T]), 
        output : QIL, default : MN, crc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL QIL'), default : parseModExp(T), crc : (MN''', CPS'', CPS'''), Atts > 
     if MN'' := parseModExp(T) 
     /\ (MN''', CPS'', CPS''', QIL') := processCRCheck(MN'', DB) .
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), default : MN, Atts > 
     if $processCRCheckAux(unitError(QIL'), CRCCS:[CRCCheckingSolution]) := processCRCheck(MN, DB) .
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processCRCheckAux(unitError(QIL'), CRCCS:[CRCCheckingSolution]) := processCRCheck(MN'', DB) .
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'Church-Rosser 'check: QIL' '\o '\n), default : MN, Atts > 
     if $processCRCheckAux(M, CRCheck(unitError(QIL'))) := processCRCheck(MN, DB) .
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'Church-Rosser 'check: QIL' '\o '\n), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processCRCheckAux(M, CRCheck(unitError(QIL'))) := processCRCheck(MN'', DB) .

---(
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser`..@Command@), 
        output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL 'Error 'in 'the 'Church-Rosser 'check. '\n
                     'Please '`, 'submit 'a 'bug 'report 'to 'duran@lcc.uma.es.), 
           default : MN, Atts > 
     if processCRCheckAux(M, CRCCS:[CRCCheckingSolution]) := processCRCheck(MN, DB) .
     ---- if VT := processCRCheck(MN, DB) 
     ---- /\ not VT :: Tuple{CritPairSet, CritPairSet, QidList} .
 crl [CRCheck] :
     < O : X@CRChC | db : DB, input : ('check`Church-Rosser_.[T]), 
        output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL 'Error 'in 'the 'Church-Rosser 'check. '\n
                     'Please '`, 'submit 'a 'bug 'report 'to 'duran@lcc.uma.es.), Atts > 
     if MN'' := parseModExp(T) 
     /\ processCRCheckAux(M, CRCCS:[CRCCheckingSolution]) := processCRCheck(MN'', DB) .
     ----/\ VT := processCRCheck(MN'', DB)
     ----/\ not VT :: Tuple{CritPairSet, CritPairSet, QidList} .
---)

**** Finally, we give the rules describing the behavior of the \texttt{ChC} object
**** associated to the new commands. In both cases the processing is carried out by
**** the \texttt{processChCCheck} function, which is called with the specified
**** module name, in the case of the \verb~check`coherence_.~ command, or with the name 
**** of the default module, for the \verb~check`coherence .~ command.

 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence`..@Command@), 
        output : QIL, default : MN, chc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL QIL'), default : MN, chc : (MN'', CPS'', CPS'''), Atts > 
     if (MN'', CPS'', CPS''', QIL') := processChCCheck(MN, false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence_.[T]), 
        output : QIL, default : MN, chc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL QIL'), default : parseModExp(T), chc : (MN''', CPS'', CPS'''), Atts > 
     if MN'' := parseModExp(T) 
     /\ (MN''', CPS'', CPS''', QIL') := processChCCheck(MN'', false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), default : MN, Atts > 
     if QIL' := processChCCheck(MN, false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence_.[T]), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), default : parseModExp(T), Atts > 
     if MN'' := parseModExp(T) 
     /\ QIL' := processChCCheck(MN'', false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), default : MN, Atts > 
     if $processChCCheckAux(unitError(QIL'), GROUND, CPST:[Tuple{CritPairSet,CritPairSet}]) := processChCCheck(MN, false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processChCCheckAux(unitError(QIL'), GROUND, CPST:[Tuple{CritPairSet,CritPairSet}]) := processChCCheck(MN'', false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'coherence 'check: QIL' '\o '\n), default : MN, Atts > 
     if $processChCCheckAux(M, GROUND, chcCheck(unitError(QIL'))) := processChCCheck(MN, false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'coherence 'check: QIL' '\o '\n), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processChCCheckAux(M, GROUND, chcCheck(unitError(QIL'))) := processChCCheck(MN'', false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'coherence 'check: QIL' '\o '\n), default : MN, Atts > 
     if $processChCCheckAux(M, GROUND, nonOverlappingCheck(unitError(QIL'))) := processChCCheck(MN, false, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'coherence 'check: QIL' '\o '\n), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processChCCheckAux(M, GROUND, nonOverlappingCheck(unitError(QIL'))) := processChCCheck(MN'', false, DB) .

 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence`..@Command@), 
        output : QIL, default : MN, chc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL QIL'), default : MN, chc : (MN'', CPS'', CPS'''), Atts > 
     if (MN'', CPS'', CPS''', QIL') := processChCCheck(MN, true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence_.[T]), 
        output : QIL, default : MN, chc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL QIL'), default : parseModExp(T), chc : (MN''', CPS'', CPS'''), Atts > 
     if MN'' := parseModExp(T) 
     /\ (MN''', CPS'', CPS''', QIL') := processChCCheck(MN'', true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), default : MN, Atts > 
     if QIL' := processChCCheck(MN, true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence_.[T]), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), default : parseModExp(T), Atts > 
     if MN'' := parseModExp(T) 
     /\ QIL' := processChCCheck(MN'', true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), default : MN, Atts > 
     if $processChCCheckAux(unitError(QIL'), GROUND, CPST:[Tuple{CritPairSet,CritPairSet}]) := processChCCheck(MN, true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL QIL'), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processChCCheckAux(unitError(QIL'), GROUND, CPST:[Tuple{CritPairSet,CritPairSet}]) := processChCCheck(MN'', true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'ground 'coherence 'check: QIL' '\o '\n), default : MN, Atts > 
     if $processChCCheckAux(M, GROUND, chcCheck(unitError(QIL'))) := processChCCheck(MN, true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'ground 'coherence 'check: QIL' '\o '\n), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processChCCheckAux(M, GROUND, chcCheck(unitError(QIL'))) := processChCCheck(MN'', true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence`..@Command@), output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'ground 'coherence 'check: QIL' '\o '\n), default : MN, Atts > 
     if $processChCCheckAux(M, GROUND, nonOverlappingCheck(unitError(QIL'))) := processChCCheck(MN, true, DB) .
 crl [GrchcCheck] :
     < O : X@CRChC | db : DB, input : ('check`ground`coherence_.[T]), output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, output : (QIL '\n '\r 'Error 'in 'the 'ground 'coherence 'check: QIL' '\o '\n), Atts > 
     if MN'' := parseModExp(T) 
     /\ $processChCCheckAux(M, GROUND, nonOverlappingCheck(unitError(QIL'))) := processChCCheck(MN'', true, DB) .

---(
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence`..@Command@), 
        output : QIL, default : MN, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL 'Error 'in 'the 'coherence 'check. '\n
                     'Please '`, 'submit 'a 'bug 'report 'to 'duran@lcc.uma.es.), default : MN, Atts > 
     if processChCCheckAux(M, CPST:[Tuple{CritPairSet,CritPairSet}]) := processChCCheck(MN, DB) .
 crl [chcCheck] :
     < O : X@CRChC | db : DB, input : ('check`coherence_.[T]), 
        output : QIL, Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (QIL 'Error 'in 'the 'coherence 'check. '\n
                     'Please '`, 'submit 'a 'bug 'report 'to 'duran@lcc.uma.es.), Atts > 
     if MN'' := parseModExp(T) 
     /\ processChCCheckAux(M, CPST:[Tuple{CritPairSet,CritPairSet}]) := processChCCheck(MN'', DB) .
---)

  rl [showCRCCPs] :
     < O : X@CRChC | db : DB, input : ('show`CRC`critical`pairs`..@Command@), 
        output : QIL, default : MN, crc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (if MN' == 'no-name.Qid and CPS == none
                     then 'No 'critical 'pairs 'to 'show. 'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously.
                     else if CPS == none 
                          then '\n 'There 'are 'no 'critical 'pairs.
                          else (QIL 
                                '\n 'The 'following 'critical 'pairs 'cannot 'be 'joined: '\o
                                eMetaPrettyPrint(
                                  getFlatModule(modExp(evalModExp(MN', DB)), 
                                    database(evalModExp(MN', DB))), 
                                  '=, 
                                  CPS'))
                          fi
                     fi), 
           default : MN, crc : (MN', CPS, CPS'), Atts > .
  rl [showChCCPs] :
     < O : X@CRChC | db : DB, input : ('show`ChC`critical`pairs`..@Command@), 
        output : QIL, default : MN, chc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (if MN' == 'no-name.Qid and CPS == none
                     then 'No 'critical 'pairs 'to 'show. 'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously.
                     else if CPS == none 
                          then '\n 'There 'are 'no 'critical 'pairs.
                          else (QIL 
                                '\n 'The 'following 'critical 'pairs 'cannot 'be 'rewritten: '\o
                                eMetaPrettyPrint(
                                  getFlatModule(modExp(evalModExp(MN', DB)), 
                                    database(evalModExp(MN', DB))), 
                                  '=>, 
                                  CPS'))
                          fi
                     fi), 
           default : MN, chc : (MN', CPS, CPS'), Atts > .
           
  rl [showAllCPs] :
     < O : X@CRChC | db : DB, input : ('show`all`CRC`critical`pairs`..@Command@), 
        output : QIL, default : MN, crc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (if MN' == 'no-name.Qid and CPS == none
                     then 'No 'critical 'pairs 'to 'show. 'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously.
                     else if CPS == none 
                          then '\n 'There 'are 'no 'critical 'pairs.
                          else (QIL 
                                '\n 'These 'are 'all 'the 'critical 'pairs: '\o
                                eMetaPrettyPrint(
                                  getFlatModule(modExp(evalModExp(MN', DB)), 
                                    database(evalModExp(MN', DB))), 
                                  '=, 
                                  CPS))
                          fi
                     fi), 
           default : MN, crc : (MN', CPS, CPS'), Atts > .
  rl [showAllChCCPs] :
     < O : X@CRChC | db : DB, input : ('show`all`ChC`critical`pairs`..@Command@), 
        output : QIL, default : MN, chc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
           output : (if MN' == 'no-name.Qid and CPS == none
                     then 'No 'critical 'pairs 'to 'show. 'One 'of 'the 'checking 'commands 'must 'be 'successfully 'executed 'previously.
                     else if CPS == none 
                          then '\n 'There 'are 'no 'critical 'pairs.
                          else (QIL 
                                '\n 'These 'are 'all 'the 'critical 'pairs: '\o
                                eMetaPrettyPrint(
                                  getFlatModule(modExp(evalModExp(MN', DB)), 
                                    database(evalModExp(MN', DB))), 
                                  '=>, 
                                  CPS))
                          fi
                     fi), 
           default : MN, chc : (MN', CPS, CPS'), Atts > .
           
  crl [ctor-split] :
     < O : X@CRChC | db : DB, input : ('ctor-split_-_on_.['token[T], 'token[T'], 'token[T'']]), 
        output : QIL, default : MN, chc : (MN', CPS, CPS'), Atts >
     => < O : X@CRChC | db : DB, input : nilTermList, 
        output : (QIL 
                  eMetaPrettyPrint(M, '=>, 
                    instantiate(M, 
                      getCP(downQid(T), downQid(T'), CPS'),
                      downQid(T''),
                      genTestSets(M, downQid(T''))))), 
        default : MN, chc : (MN', CPS, CPS'), Atts >
     if M := getFlatModule(modExp(evalModExp(MN', DB)), database(evalModExp(MN', DB))) .
           
  op getCP : Qid Qid CritPairSet -> CritPairSet .
  eq getCP(QI, QI', cp(QI, QI', T, T') CPS) = cp(QI, QI', T, T') getCP(QI, QI', CPS) .
  eq getCP(QI, QI', ccp(QI, QI', T, T', Cd) CPS) = ccp(QI, QI', T, T', Cd) getCP(QI, QI', CPS) .
  eq getCP(QI, QI', CPS) = none [owise] .
  
  op instantiate : Module CritPairSet Qid TermSet -> CritPairSet .
  eq instantiate(M, CP CPS, V, TS)
    = substitute(M, CP, V, TS) instantiate(M, CPS, V, TS) .
  eq instantiate(M, none, V, TS) = none .
  
  op substitute : Module CritPair Variable TermSet -> CritPairSet .
  eq substitute(M, cp(QI, QI', T, T'), V, T'' | TS)
    = cp(QI, QI', substitute(M, T, V <- T''), substitute(M, T', V <- T''))
      substitute(M, cp(QI, QI', T, T'), V, TS) .
  eq substitute(M, ccp(QI, QI', T, T', Cd), V, T'' | TS)
    = ccp(QI, QI', substitute(M, T, V <- T''), substitute(M, T', V <- T''), substitute(M, Cd, V <- T'')) 
      substitute(M, ccp(QI, QI', T, T', Cd), V, TS) .
  eq substitute(M, cp(QI, QI', T, T'), V, emptyTermSet) = none .
  
  ---- ctorEqs returns those equations with a constructor at the top
  op ctorEqs : Module -> EquationSet .
  op ctorEqs : Module EquationSet -> EquationSet .
 
  eq ctorEqs(M) = ctorEqs(M, getEqs(M)) .

  eq ctorEqs(M, Eq EqS) 
    = if ctor(M, getOps(M), lhs(Eq)) 
      then Eq 
      else none
      fi
      ctorEqs(M, EqS) .
  eq ctorEqs(M, none) = none .
  
  ---- chReq returns those equations that are not either left-linear, 
  ---- right-linear, or regular.  
  op chReq : EquationSet -> EquationSet .
  ---- left-linear checks whether the equation is left-linear
  op left-linear : Equation -> Bool .
  ---- left-linear checks whether the equation is right-linear
  op right-linear : Equation -> Bool .
  ---- left-linear checks whether the equation is regular
  op regular : Equation -> Bool .
  ---- linear checks whether there are vbles repeated in the term
  op linear : Term -> Bool .
  ---- vbList returns a list with the variables in the term 
  ---- the order is not important, a multiset could be used.
  op vbList : Term -> QidList .
  ---- repeated checks whether there are repeated qids in the given list.
  op repeated : QidList -> Bool .
  
  eq chReq(Eq EqS) 
    = if left-linear(Eq) and-then right-linear(Eq) and-then regular(Eq) 
      then none
      else Eq
      fi
      chReq(EqS) .
  eq chReq(none) = none .
 
  eq left-linear(Eq) = linear(lhs(Eq)) . 
  eq right-linear(Eq) = linear(rhs(Eq)) . 
  eq regular(Eq) = makeSet(vbList(lhs(Eq))) == makeSet(vbList(rhs(Eq))) . 

  eq linear(T) = not repeated(vbList(T)) .
  
  eq vbList(Vb) = Vb . 
  eq vbList(Ct) = nil .
  eq vbList(F[TL]) = vbList(TL) .
  eq vbList((T, TL)) = vbList(T) vbList(TL) .
  
  eq repeated(QI QIL) = occurs(QI, QIL) or-else repeated(QIL) .
  eq repeated(nil) = false .
  
  ---- test set generation 
  
   op genTestSets : Module Variable -> TermSet .
   op testsForType : Module Type Nat OpDeclSet TermSet -> Tuple{Nat, TermSet} .
   op testGivenArity : Nat TypeList -> Tuple{Nat, TermList} .
   op testGivenArity : Nat TypeList TermList -> Tuple{Nat, TermList} .

   eq genTestSets(M, V) = p2(testsForType(M, getType(V), 0, getOps(M), emptyTermSet)) .
   
   eq testsForType(M, Tp, N, ((op F : nil -> Tp' [ctor AtS] .) ODS), TS)
     = if sortLeq(M, Tp', Tp)
       then testsForType(M, Tp, N, ODS, TS | qid(string(F) + "." + string(Tp')))
       else testsForType(M, Tp, N, ODS, TS)
       fi .
   eq testsForType(M, Tp, N, ((op F : TpL -> Tp' [ctor AtS] .) ODS), TS)
     = if sortLeq(M, Tp', Tp)
       then testsForType(M, Tp, p1(testGivenArity(N, TpL)), ODS,
              (TS | (F[p2(testGivenArity(N, TpL, empty))])))
       else testsForType(M, Tp, N, ODS, TS)
       fi
     [owise] .       
   eq testsForType(M, Tp, N, ((op F : TpL -> Tp' [AtS] .) ODS), TS)
     = (N, TS)
     [owise] .

   eq testGivenArity(N, (Tp TpL), TL) 
     = testGivenArity(N + 1, TpL, (TL, qid("#" + string(N, 10) + ":" + string(Tp)))) .
   eq testGivenArity(N, nil, TL) = [N, TL] .
endm


*** Redefinition of the FULL-MAUDE module. The init rule now creates an 
*** instance of class CRChC. The init rule now takes CRChC objects, and for them 
*** it uses CRCHC-GRAMMAR instead of GRAMMAR to parse inputs. 

mod CRCHC is
  pr META-CRCHC-SIGN .
  pr CRCHC-DATABASE-HANDLING .
  inc LOOP-MODE .
  pr BANNER .
  pr CRC-BANNER .
  pr CHC-BANNER .

  subsort Object < State .

  op o : -> Oid .
  op init : -> System .

  var  Atts : AttributeSet .
  var  X@CRChC : DatabaseClass .
  var  O : Oid .
  var  DB : Database .
  var  ME : Header .
  var  QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  N : Nat .
  vars RP RP' : ResultPair .

  rl [init] :
     init
     => [nil,
         < o : CRChC | 
            db : initialDatabase,
            input : nilTermList, output : nil, 
            default : 'CONVERSION, 
            crc : ('no-name.Qid, none, none), 
            chc : ('no-name.Qid, none, none) >,
         ----'\n 
         ('\s '\s '\s '\s string2qidList(crc-banner) '\n)
         ('\s '\s '\s '\s string2qidList(chc-banner) '\n)
         ] .

  rl [in] :
    [QI QIL, 
     < O : X@CRChC | 
         db : DB, input : nilTermList, output : nil, default : ME, Atts >, 
     QIL']
    => if metaParse(CRCHC-GRAMMAR, QI QIL, '@Input@) :: ResultPair
       then [nil, 
             < O : X@CRChC | db : DB, 
                 input : getTerm(metaParse(CRCHC-GRAMMAR, QI QIL, '@Input@)),
                 output : nil, default : ME, Atts >, 
              QIL'] 
       else [nil, 
             < O : X@CRChC | db : DB, input : nilTermList, 
                 output : ('\r 'Warning: 
                           printSyntaxError(
                             metaParse(CRCHC-GRAMMAR, QI QIL, '@Input@), 
                             QI QIL) 
                           '\n
                           '\r 'Error: '\o 'No 'parse 'for 'input. '\n), 
                 default : ME, Atts >, 
             QIL'] 
       fi .

  rl [out] :
    [QIL, 
     < O : X@CRChC | 
         db : DB, input : TL, output : (QI QIL'), default : ME, Atts >, 
     QIL'']
    => [QIL, 
        < O : X@CRChC | 
            db : DB, input : TL, output : nil, default : ME, Atts >, 
        (QI QIL' QIL'')] .

  rl [help] :
     < O : X@CRChC | input : ('help`..@Command@), output : QIL, Atts >
     => < O : X@CRChC | input : nilTermList, 
           output : (crc-help chc-help), Atts > .
endm

loop init .

(set include BOOL off .)
(set include TRUTH-VALUE on .)

---- trace exclude CRCHC .

set show loop stats on .
set show loop timing on .
set show advisories off .
